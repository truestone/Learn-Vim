# Ch09. 매크로

파일을 편집할 때, 같은 동작을 반복하고 있는 자신을 발견할 수 있습니다. 그 동작들을 한 번만 하고 필요할 때마다 다시 재생할 수 있다면 좋지 않을까요? Vim 매크로를 사용하면 동작을 기록하고 필요할 때마다 실행할 수 있도록 Vim 레지스터 안에 저장할 수 있습니다.

이 장에서는 매크로를 사용하여 지루한 작업을 자동화하는 방법을 배울 것입니다 (게다가 파일이 스스로 편집되는 것을 보는 것은 멋져 보입니다).

## 기본 매크로

다음은 Vim 매크로의 기본 구문입니다:

```
qa                     a 레지스터에 매크로 기록 시작
q (기록 중)    매크로 기록 중지
```

매크로를 저장하기 위해 소문자(a-z)를 선택할 수 있습니다. 다음은 매크로를 실행하는 방법입니다:

```
@a    a 레지스터에서 매크로 실행
@@    마지막으로 실행된 매크로 실행
```

다음과 같은 텍스트가 있고 각 줄의 모든 것을 대문자로 만들고 싶다고 가정해 봅시다:

```
hello
vim
macros
are
awesome
```

"hello" 줄의 시작에 커서를 놓고 다음을 실행하세요:

```
qa0gU$jq
```

분석:
- `qa`는 a 레지스터에 매크로 기록을 시작합니다.
- `0`은 줄의 시작으로 이동합니다.
- `gU$`는 현재 위치에서 줄 끝까지의 텍스트를 대문자로 만듭니다.
- `j`는 한 줄 아래로 이동합니다.
- `q`는 기록을 중지합니다.

다시 재생하려면 `@a`를 실행하세요. 다른 많은 Vim 명령어와 마찬가지로, 매크로에 횟수 인수를 전달할 수 있습니다. 예를 들어, `3@a`를 실행하면 매크로가 세 번 실행됩니다.

## 안전 장치

매크로 실행은 오류를 만나면 자동으로 종료됩니다. 다음과 같은 텍스트가 있다고 가정해 봅시다:

```
a. chocolate donut
b. mochi donut
c. powdered sugar donut
d. plain donut
```

각 줄의 첫 단어를 대문자로 만들고 싶다면, 이 매크로가 작동할 것입니다:

```
qa0W~jq
```

위 명령어의 분석은 다음과 같습니다:
- `qa`는 a 레지스터에 매크로 기록을 시작합니다.
- `0`은 줄의 시작으로 이동합니다.
- `W`는 다음 WORD로 이동합니다.
- `~`는 커서 아래 문자의 대소문자를 전환합니다.
- `j`는 한 줄 아래로 이동합니다.
- `q`는 기록을 중지합니다.

저는 매크로 실행 횟수를 적게 세는 것보다 많이 세는 것을 선호하므로, 보통 99번 호출합니다(`99@a`). 이 명령어로, Vim은 실제로 이 매크로를 99번 실행하지 않습니다. Vim이 마지막 줄에 도달하고 `j` 모션을 실행하면, 더 이상 내려갈 줄이 없다는 것을 발견하고 오류를 발생시키며 매크로 실행을 중지합니다.

매크로 실행이 첫 번째 오류 발생 시 중지된다는 사실은 좋은 기능입니다. 그렇지 않으면 Vim은 이미 줄의 끝에 도달했음에도 불구하고 이 매크로를 99번 계속 실행할 것입니다.

## 커맨드 라인 매크로

일반 모드에서 `@a`를 실행하는 것이 Vim에서 매크로를 실행하는 유일한 방법은 아닙니다. `:normal @a` 커맨드 라인을 실행할 수도 있습니다. `:normal`은 사용자가 인수로 전달된 모든 일반 모드 명령어를 실행할 수 있게 해줍니다. 위의 경우, 일반 모드에서 `@a`를 실행하는 것과 같습니다.

`:normal` 명령어는 범위를 인수로 받습니다. 이것을 사용하여 선택한 범위에서 매크로를 실행할 수 있습니다. 2번 줄과 3번 줄 사이에서 매크로를 실행하고 싶다면, `:2,3 normal @a`를 실행할 수 있습니다.

## 여러 파일에 걸쳐 매크로 실행하기

각각 일부 텍스트를 포함하는 여러 `.txt` 파일이 있다고 가정해 봅시다. 당신의 임무는 "donut"이라는 단어를 포함하는 줄에서만 첫 단어를 대문자로 만드는 것입니다. a 레지스터에 `0W~j`가 있다고 가정합니다 (이전과 동일한 매크로). 어떻게 이것을 빨리 달성할 수 있을까요?

첫 번째 파일:

```
## savory.txt
a. cheddar jalapeno donut
b. mac n cheese donut
c. fried dumpling
```

두 번째 파일:

```
## sweet.txt
a. chocolate donut
b. chocolate pancake
c. powdered sugar donut
```

세 번째 파일:

```
## plain.txt
a. wheat bread
b. plain donut
```

다음과 같이 할 수 있습니다:
- `:args *.txt`로 현재 디렉토리의 모든 `.txt` 파일을 찾습니다.
- `:argdo g/donut/normal @a`는 `:args` 안의 각 파일에 대해 전역 명령어 `g/donut/normal @a`를 실행합니다.
- `:argdo update`는 버퍼가 수정되었을 때 `:args` 안의 각 파일을 저장하기 위해 `update` 명령어를 실행합니다.

전역 명령어 `:g/donut/normal @a`에 익숙하지 않다면, 패턴(`/donut/`)과 일치하는 줄에 대해 주어진 명령어(`normal @a`)를 실행합니다. 나중 장에서 전역 명령어에 대해 다룰 것입니다.

## 재귀 매크로

매크로를 기록하는 동안 동일한 매크로 레지스터를 호출하여 재귀적으로 매크로를 실행할 수 있습니다. 다시 이 목록이 있고 첫 단어의 대소문자를 전환해야 한다고 가정해 봅시다:

```
a. chocolate donut
b. mochi donut
c. powdered sugar donut
d. plain donut
```

이번에는 재귀적으로 해봅시다. 다음을 실행하세요:

```
qaqqa0W~j@aq
```

단계별 분석은 다음과 같습니다:
- `qaq`는 빈 매크로 a를 기록합니다. 재귀적으로 매크로를 호출할 때 해당 레지스터에 있는 모든 것을 실행하기 때문에 빈 레지스터로 시작하는 것이 필요합니다.
- `qa`는 a 레지스터에 기록을 시작합니다.
- `0`은 현재 줄의 첫 문자로 이동합니다.
- `W`는 다음 WORD로 이동합니다.
- `~`는 커서 아래 문자의 대소문자를 전환합니다.
- `j`는 한 줄 아래로 이동합니다.
- `@a`는 매크로 a를 실행합니다.
- `q`는 기록을 중지합니다.

이제 `@a`를 실행하고 Vim이 재귀적으로 매크로를 실행하는 것을 지켜볼 수 있습니다.

매크로는 언제 멈춰야 하는지 어떻게 알았을까요? 매크로가 마지막 줄에 있을 때 `j`를 실행하려고 했지만, 더 이상 갈 줄이 없었기 때문에 매크로 실행을 중지했습니다.

## 매크로 추가하기

기존 매크로에 동작을 추가해야 하는 경우, 매크로를 처음부터 다시 만드는 대신 기존 매크로에 동작을 추가할 수 있습니다. 레지스터 장에서, 대문자 기호를 사용하여 명명된 레지스터에 추가할 수 있다는 것을 배웠습니다. 동일한 규칙이 적용됩니다. a 매크로 레지스터에 동작을 추가하려면, A 레지스터를 사용하세요.

a 레지스터에 매크로를 기록하세요: `qa0W~q` (이 시퀀스는 한 줄의 다음 WORD의 대소문자를 전환합니다). 줄 끝에 점을 추가하는 새로운 시퀀스를 추가하고 싶다면, 다음을 실행하세요:

```
qAA.<Esc>q
```

분석:
- `qA`는 A 레지스터에 매크로 기록을 시작합니다.
- `A.<Esc>`는 줄 끝에 (여기서 `A`는 삽입 모드 명령어이며, 매크로 A와 혼동해서는 안 됨) 점을 삽입한 다음, 삽입 모드를 종료합니다.
- `q`는 매크로 기록을 중지합니다.

이제 `@a`를 실행하면, 다음 WORD의 대소문자를 전환할 뿐만 아니라 줄 끝에 점도 추가합니다.

## 매크로 수정하기

매크로 중간에 새로운 동작을 추가해야 한다면 어떻게 해야 할까요?

첫 번째 실제 단어의 대소문자를 전환하고 줄 끝에 마침표를 추가하는 매크로, 즉 a 레지스터에 `0W~A.<Esc>`가 있다고 가정해 봅시다. 첫 단어를 대문자로 만들고 줄 끝에 마침표를 추가하는 사이에, "donut"이라는 단어 바로 앞에 "deep fried"라는 단어를 추가해야 한다고 가정해 봅시다 *(일반 도넛보다 튀긴 도넛이 더 맛있기 때문입니다)*.

이전 섹션의 텍스트를 재사용하겠습니다:
```
a. chocolate donut
b. mochi donut
c. powdered sugar donut
d. plain donut
```

먼저, `:put a`로 기존 매크로(이전 섹션의 매크로를 a 레지스터에 보관했다고 가정)를 호출해 봅시다:

```
0W~A.^[
```

이 `^[`는 무엇일까요? `0W~A.<Esc>`를 하지 않았나요? `<Esc>`는 어디에 있나요? `^[`는 Vim의 `<Esc>`에 대한 *내부 코드* 표현입니다. 특정 특수 키의 경우, Vim은 해당 키의 표현을 내부 코드 형태로 출력합니다. 내부 코드 표현이 있는 일반적인 키로는 `<Esc>`, `<Backspace>`, `<Enter>`가 있습니다. 더 많은 특수 키가 있지만, 이 장의 범위를 벗어납니다.

매크로로 돌아가서, 대소문자 전환 연산자(`~`) 바로 뒤에, 줄 끝으로 이동(`$`), 한 단어 뒤로 이동(`b`), 삽입 모드로 이동(`i`), "deep fried " 입력("fried " 뒤의 공백을 잊지 마세요), 그리고 삽입 모드 종료(`<Esc>`) 지침을 추가해 봅시다.

결국 다음과 같이 될 것입니다:

```
0W~$bideep fried <Esc>A.^[
```

작은 문제가 있습니다. Vim은 `<Esc>`를 이해하지 못합니다. 문자 그대로 `<Esc>`를 입력할 수 없습니다. `<Esc>` 키에 대한 내부 코드 표현을 작성해야 합니다. 삽입 모드에 있는 동안 `Ctrl-V`를 누른 다음 `<Esc>`를 누릅니다. Vim은 `^[`를 출력합니다. `Ctrl-V`는 다음 비-숫자 문자를 *문자 그대로* 삽입하는 삽입 모드 연산자입니다. 이제 매크로 코드는 다음과 같아야 합니다:

```
0W~$bideep fried ^[A.^[
```

수정된 지침을 a 레지스터에 추가하려면, 명명된 레지스터에 새 항목을 추가하는 것과 같은 방식으로 할 수 있습니다. 줄의 시작에서 `"ay$`를 실행하여 복사된 텍스트를 a 레지스터에 저장합니다.

이제 `@a`를 실행하면, 매크로가 첫 단어의 대소문자를 전환하고, "donut" 앞에 "deep fried "를 추가하고, 줄 끝에 "."을 추가합니다. 맛있겠네요!

매크로를 수정하는 다른 방법은 커맨드 라인 표현식을 사용하는 것입니다. `:let @a="`를 한 다음, `Ctrl-R a`를 하면, a 레지스터의 내용을 문자 그대로 붙여넣습니다. 마지막으로, 큰따옴표(`"`)를 닫는 것을 잊지 마세요. `:let @a="0W~$bideep fried ^[A.^["`와 같은 것을 가질 수 있습니다.

## 매크로 중복

한 레지스터에서 다른 레지스터로 매크로를 쉽게 복제할 수 있습니다. 예를 들어, a 레지스터의 매크로를 z 레지스터로 복제하려면 `:let @z = @a`를 할 수 있습니다. `@a`는 a 레지스터의 내용을 나타냅니다. 이제 `@z`를 실행하면 `@a`와 똑같은 동작을 합니다.

가장 자주 사용하는 매크로에 중복을 만드는 것이 유용하다고 생각합니다. 제 작업 흐름에서는 보통 처음 일곱 개의 알파벳 문자(a-g)에 매크로를 기록하고, 별 생각 없이 교체하는 경우가 많습니다. 유용한 매크로를 알파벳 끝으로 옮기면, 실수로 교체할 걱정 없이 보존할 수 있습니다.

## 직렬 대 병렬 매크로

Vim은 매크로를 직렬 및 병렬로 실행할 수 있습니다. 다음과 같은 텍스트가 있다고 가정해 봅시다:

```
import { FUNC1 } from "library1";
import { FUNC2 } from "library2";
import { FUNC3 } from "library3";
import { FUNC4 } from "library4";
import { FUNC5 } from "library5";
```

대문자로 된 모든 "FUNC"를 소문자로 만드는 매크로를 기록하고 싶다면, 이 매크로가 작동할 것입니다:

```
qa0f{gui{jq
```

분석:
- `qa`는 a 레지스터에 기록을 시작합니다.
- `0`은 첫 줄로 이동합니다.
- `f{`는 "{"의 첫 번째 인스턴스를 찾습니다.
- `gui{`는 대괄호 텍스트 객체(`i{`) 안의 텍스트를 소문자로 만듭니다(`gu`).
- `j`는 한 줄 아래로 이동합니다.
- `q`는 매크로 기록을 중지합니다.

이제 `99@a`를 실행하여 나머지 줄에 대해 실행할 수 있습니다. 하지만 파일 안에 이런 import 표현식이 있다면 어떨까요?

```
import { FUNC1 } from "library1";
import { FUNC2 } from "library2";
import { FUNC3 } from "library3";
import foo from "bar";
import { FUNC4 } from "library4";
import { FUNC5 } from "library5";
```

`99@a`를 실행하면, 매크로가 세 번만 실행됩니다. "foo" 줄에서 `f{` 실행에 실패하여 마지막 두 줄에서는 매크로가 실행되지 않습니다. 이것은 매크로를 직렬로 실행할 때 예상되는 현상입니다. 언제든지 "FUNC4"가 있는 다음 줄로 가서 해당 매크로를 다시 재생할 수 있습니다. 하지만 한 번에 모든 것을 처리하고 싶다면 어떨까요?

매크로를 병렬로 실행하세요.

이전 섹션에서 매크로가 커맨드 라인 명령어 `:normal`을 사용하여 실행될 수 있다는 것을 상기하세요 (예: `:3,5 normal @a`는 3-5번 줄에서 매크로 a를 실행). `:1,$ normal @a`를 실행하면, "foo" 줄을 제외한 모든 줄에서 매크로가 실행되는 것을 볼 수 있습니다. 작동합니다!

내부적으로 Vim은 실제로 매크로를 병렬로 실행하지 않지만, 외부적으로는 그렇게 작동하는 것처럼 보입니다. Vim은 첫 번째 줄부터 마지막 줄까지(`1,$`) 각 줄에서 `@a`를 *독립적으로* 실행합니다. Vim이 이러한 매크로를 독립적으로 실행하기 때문에, 각 줄은 "foo" 줄에서 매크로 실행 중 하나가 실패했다는 것을 알지 못합니다.

## 현명하게 매크로 배우기

편집에서 하는 많은 일들이 반복적입니다. 편집을 더 잘하려면, 반복적인 동작을 감지하는 습관을 들이세요. 같은 동작을 두 번 하지 않도록 매크로(또는 점 명령어)를 사용하세요. Vim에서 할 수 있는 거의 모든 것은 매크로로 복제할 수 있습니다.

처음에는 매크로를 작성하는 것이 매우 어색했지만, 포기하지 마세요. 충분한 연습을 통해 모든 것을 자동화하는 습관을 갖게 될 것입니다.

매크로를 기억하는 데 도움이 되도록 니모닉을 사용하는 것이 도움이 될 수 있습니다. 함수를 만드는 매크로가 있다면, "f 레지스터를 사용하세요(`qf`). 숫자 연산을 위한 매크로가 있다면, "n 레지스터가 작동할 것입니다(`qn`). 그 작업을 생각할 때 마음에 떠오르는 *첫 번째 명명된 레지스터*로 이름을 지정하세요. 또한 "q 레지스터가 좋은 기본 매크로 레지스터라고 생각합니다. 왜냐하면 `qq`는 생각해내는 데 더 적은 두뇌 능력이 필요하기 때문입니다. 마지막으로, 저는 매크로를 알파벳 순서대로, 예를 들어 `qa`, `qb`, `qc` 등으로 증가시키는 것을 좋아합니다.

자신에게 가장 잘 맞는 방법을 찾으세요.