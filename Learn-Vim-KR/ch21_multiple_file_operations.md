# 여러 파일 작업

여러 파일에서 업데이트할 수 있는 것은 또 다른 유용한 편집 도구입니다. 이전에 `cfdo`로 여러 텍스트를 업데이트하는 방법을 배웠습니다. 이 장에서는 Vim에서 여러 파일을 편집하는 다양한 방법을 배웁니다.

## 여러 파일에서 명령어를 실행하는 다양한 방법

Vim에는 여러 파일에 걸쳐 명령어를 실행하는 여덟 가지 방법이 있습니다:
- 인수 목록 (`argdo`)
- 버퍼 목록 (`bufdo`)
- 창 목록 (`windo`)
- 탭 목록 (`tabdo`)
- 빠른 수정 목록 (`cdo`)
- 빠른 수정 목록 파일 단위 (`cfdo`)
- 위치 목록 (`ldo`)
- 위치 목록 파일 단위 (`lfdo`)

실질적으로, 대부분의 경우 한두 가지만 사용할 것입니다(저는 개인적으로 다른 것보다 `cdo`와 `argdo`를 더 많이 사용합니다). 하지만 사용 가능한 모든 옵션에 대해 배우고 자신의 편집 스타일에 맞는 것을 사용하는 것이 좋습니다.

여덟 가지 명령어를 배우는 것은 벅차게 들릴 수 있습니다. 하지만 실제로는 이러한 명령어들이 비슷하게 작동합니다. 하나를 배우고 나면 나머지를 배우는 것이 더 쉬워집니다. 모두 같은 큰 아이디어를 공유합니다: 각 카테고리의 목록을 만든 다음 실행하고 싶은 명령어를 전달합니다.

## 인수 목록

인수 목록은 가장 기본적인 목록입니다. 파일 목록을 만듭니다. file1, file2, file3의 목록을 만들려면 다음을 실행할 수 있습니다:

```
:args file1 file2 file3
```

와일드카드(`*`)를 전달할 수도 있으므로, 현재 디렉토리의 모든 `.js` 파일 목록을 만들고 싶다면 다음을 실행하세요:

```
:args *.js
```

현재 디렉토리에서 "a"로 시작하는 모든 자바스크립트 파일 목록을 만들고 싶다면 다음을 실행하세요:

```
:args a*.js
```

와일드카드는 현재 디렉토리의 모든 파일 이름 문자 중 하나 이상과 일치하지만, 모든 디렉토리에서 재귀적으로 검색해야 한다면 어떨까요? 이중 와일드카드(`**`)를 사용할 수 있습니다. 현재 위치 내의 디렉토리 안에 있는 모든 자바스크립트 파일을 가져오려면 다음을 실행하세요:

```
:args **/*.js
```

`args` 명령어를 실행하면, 현재 버퍼가 목록의 첫 번째 항목으로 전환됩니다. 방금 만든 파일 목록을 보려면 `:args`를 실행하세요. 목록을 만든 후에는 탐색할 수 있습니다. `:first`는 목록의 첫 번째 항목에 위치시킵니다. `:last`는 마지막 목록에 위치시킵니다. 목록을 한 번에 한 파일씩 앞으로 이동하려면 `:next`를 실행하세요. 목록을 한 번에 한 파일씩 뒤로 이동하려면 `:prev`를 실행하세요. 한 번에 한 파일씩 앞/뒤로 이동하고 변경 사항을 저장하려면 `:wnext`와 `:wprev`를 실행하세요. 더 많은 탐색 명령어가 있습니다. 더 많은 정보는 `:h arglist`를 확인하세요.

인수 목록은 특정 유형의 파일이나 몇 개의 파일을 대상으로 해야 할 때 유용합니다. 모든 `yml` 파일 안의 모든 "donut"을 "pancake"로 업데이트해야 한다면 다음을 수행할 수 있습니다:

```
:args **/*.yml
:argdo %s/donut/pancake/g | update

```
`args` 명령어를 다시 실행하면 이전 목록을 대체합니다. 예를 들어, 이전에 다음을 실행했다면:

```
:args file1 file2 file3
```

이 파일들이 존재한다고 가정하면, 이제 `file1`, `file2`, `file3`의 목록이 있습니다. 그런 다음 이것을 실행합니다:

```
:args file4 file5
```

초기 `file1`, `file2`, `file3` 목록이 `file4`와 `file5`로 대체됩니다. 인수 목록에 `file1`, `file2`, `file3`이 있고 초기 파일 목록에 `file4`와 `file5`를 *추가*하고 싶다면, `:arga` 명령어를 사용하세요. 다음을 실행하세요:

```
:arga file4 file5
```

이제 인수 목록에 `file1`, `file2`, `file3`, `file4`, `file5`가 있습니다.

인수 없이 `:arga`를 실행하면, Vim은 현재 버퍼를 현재 인수 목록에 추가합니다. 인수 목록에 `file1`, `file2`, `file3`이 있고 현재 버퍼가 `file5`에 있다면, `:arga`를 실행하면 `file5`가 목록에 추가됩니다.

목록이 있으면, 선택한 모든 커맨드-라인 명령어로 전달할 수 있습니다. 치환(`:argdo %s/donut/pancake/g`)으로 수행되는 것을 보았습니다. 다른 예:
- 인수 목록 전체에서 "dessert"를 포함하는 모든 줄을 삭제하려면 `:argdo g/dessert/d`를 실행하세요.
- 인수 목록 전체에서 매크로 a를 실행하려면(매크로 a에 무언가를 기록했다고 가정), `:argdo norm @a`를 실행하세요.
- 첫 번째 줄에 "hello "와 파일 이름을 쓰려면 `:argdo 0put='hello ' .. @:`를 실행하세요.

완료되면 `:update`로 저장하는 것을 잊지 마세요.

때로는 인수 목록의 처음 n개 항목에 대해서만 명령어를 실행해야 할 수도 있습니다. 그럴 경우, `argdo` 명령어에 주소를 전달하기만 하면 됩니다. 예를 들어, 목록의 처음 3개 항목에 대해서만 치환 명령어를 실행하려면 `:1,3argdo %s/donut/pancake/g`를 실행하세요.

## 버퍼 목록

버퍼 목록은 새 파일을 편집할 때 유기적으로 생성됩니다. 왜냐하면 새 파일을 만들거나 파일을 열 때마다 Vim이 버퍼에 저장하기 때문입니다(명시적으로 삭제하지 않는 한). 따라서 이미 3개의 파일(`file1.rb file2.rb file3.rb`)을 열었다면, 이미 버퍼 목록에 3개의 항목이 있습니다. 버퍼 목록을 표시하려면 `:buffers`를 실행하세요(또는 `:ls` 또는 `:files`). 앞뒤로 탐색하려면 `:bnext`와 `:bprev`를 사용하세요. 목록의 첫 번째와 마지막 버퍼로 이동하려면 `:bfirst`와 `:blast`를 사용하세요(아직도 신나나요? :D).

그런데, 이 장과 관련 없는 멋진 버퍼 트릭이 있습니다: 버퍼 목록에 여러 항목이 있다면, `:ball`(buffer all)로 모두 표시할 수 있습니다. `ball` 명령어는 모든 버퍼를 수평으로 표시합니다. 수직으로 표시하려면 `:vertical ball`을 실행하세요.

주제로 돌아가서, 모든 버퍼에 걸쳐 작업을 실행하는 메커니즘은 인수 목록과 유사합니다. 버퍼 목록을 만든 후에는, 실행하려는 명령어를 `:argdo` 대신 `:bufdo`로 시작하기만 하면 됩니다. 따라서 모든 버퍼에서 모든 "donut"을 "pancake"로 치환한 다음 변경 사항을 저장하고 싶다면 `:bufdo %s/donut/pancake/g | update`를 실행하세요.

## 창 및 탭 목록

창 및 탭 목록도 인수 및 버퍼 목록과 유사합니다. 유일한 차이점은 컨텍스트와 구문입니다.

창 작업은 각 열린 창에서 수행되며 `:windo`로 수행됩니다. 탭 작업은 열려 있는 각 탭에서 수행되며 `:tabdo`로 수행됩니다. 더 많은 정보는 `:h list-repeat`, `:h :windo`, `:h :tabdo`를 확인하세요.

예를 들어, 세 개의 창이 열려 있고(수직 창은 `Ctrl-W v`, 수평 창은 `Ctrl-W s`로 새 창을 열 수 있음) `:windo 0put ='hello' . @%`를 실행하면, Vim은 열려 있는 모든 창에 "hello" + 파일 이름을 출력합니다.

## 빠른 수정 목록

이전 장(Ch3 및 Ch19)에서 빠른 수정에 대해 이야기했습니다. 빠른 수정에는 많은 용도가 있습니다. 많은 인기 있는 플러그인이 빠른 수정을 사용하므로, 그것들을 이해하는 데 더 많은 시간을 할애하는 것이 좋습니다.

Vim을 처음 사용하는 경우, 빠른 수정은 새로운 개념일 수 있습니다. 예전에는 코드를 명시적으로 컴파일해야 했던 시절, 컴파일 단계에서 오류가 발생했습니다. 이러한 오류를 표시하려면 특별한 창이 필요했습니다. 바로 여기서 빠른 수정이 등장합니다. 코드를 컴파일하면 Vim은 빠른 수정 창에 오류 메시지를 표시하여 나중에 수정할 수 있도록 합니다. 많은 현대 언어는 더 이상 명시적인 컴파일이 필요하지 않지만, 그렇다고 해서 빠른 수정이 쓸모없어지는 것은 아닙니다. 요즘 사람들은 가상 터미널 출력을 표시하고 검색 결과를 저장하는 등 모든 종류의 일에 빠른 수정을 사용합니다. 후자인 검색 결과 저장에 초점을 맞춰 봅시다.

컴파일 명령어 외에도, 특정 Vim 명령어는 빠른 수정 인터페이스에 의존합니다. 빠른 수정을 많이 사용하는 한 가지 유형의 명령어는 검색 명령어입니다. `:vimgrep`과 `:grep`은 모두 기본적으로 빠른 수정을 사용합니다.

예를 들어, 모든 자바스크립트 파일에서 재귀적으로 "donut"을 검색해야 하는 경우 다음을 실행할 수 있습니다:

```
:vimgrep /donut/ **/*.js
```

"donut" 검색 결과는 빠른 수정 창에 저장됩니다. 이러한 일치 결과의 빠른 수정 창을 보려면 다음을 실행하세요:

```
:copen
```

닫으려면 다음을 실행하세요:

```
:cclose
```

빠른 수정 목록을 앞뒤로 탐색하려면 다음을 실행하세요:

```
:cnext
:cprev
```

일치하는 항목의 첫 번째와 마지막 항목으로 이동하려면 다음을 실행하세요:

```
:cfirst
:clast
```

앞서 두 가지 빠른 수정 명령어가 있다고 언급했습니다: `cdo`와 `cfdo`. 어떻게 다를까요? `cdo`는 빠른 수정 목록의 각 항목에 대해 명령어를 실행하는 반면, `cfdo`는 빠른 수정 목록의 각 *파일*에 대해 명령어를 실행합니다.

명확히 설명하겠습니다. 위 `vimgrep` 명령어를 실행한 후 다음을 발견했다고 가정해 봅시다:
- `file1.js`에서 1개의 결과
- `file2.js`에서 10개의 결과

`:cfdo %s/donut/pancake/g`를 실행하면, 이것은 `file1.js`에서 한 번, `file2.js`에서 한 번 `%s/donut/pancake/g`를 효과적으로 실행합니다. 일치하는 파일 수만큼 실행됩니다. 결과에 두 개의 파일이 있으므로, 두 번째 파일에 10개의 일치 항목이 있음에도 불구하고 Vim은 `file1.js`에서 한 번, `file2.js`에서 한 번 더 치환 명령어를 실행합니다. `cfdo`는 빠른 수정 목록에 있는 총 파일 수에만 관심이 있습니다.

`:cdo %s/donut/pancake/g`를 실행하면, 이것은 `file1.js`에서 한 번, `file2.js`에서 *열 번* `%s/donut/pancake/g`를 효과적으로 실행합니다. 빠른 수정 목록에 있는 실제 항목 수만큼 실행됩니다. `file1.js`에서 발견된 일치 항목이 하나뿐이고 `file2.js`에서 발견된 일치 항목이 10개이므로, 총 11번 실행됩니다.

`%s/donut/pancake/g`를 실행했으므로, `cfdo`를 사용하는 것이 합리적입니다. `cdo`를 사용하는 것은 의미가 없습니다. 왜냐하면 `file2.js`에서 `%s/donut/pancake/g`를 열 번 실행할 것이기 때문입니다(`%s`는 파일 전체 치환입니다). 파일당 한 번 `%s`를 실행하는 것으로 충분합니다. `cdo`를 사용했다면, 대신 `s/donut/pancake/g`를 전달하는 것이 더 합리적일 것입니다.

`cfdo`를 사용할지 `cdo`를 사용할지 결정할 때, 전달하는 명령어의 범위를 생각해보세요. 이것이 파일 전체 명령어(예: `:%s` 또는 `:g`)인가요, 아니면 줄 단위 명령어(예: `:s` 또는 `:!`)인가요?

## 위치 목록

위치 목록은 Vim이 메시지를 표시하기 위해 특별한 창을 사용한다는 점에서 빠른 수정 목록과 유사합니다. 빠른 수정 목록과 위치 목록의 차이점은 언제든지 하나의 빠른 수정 목록만 가질 수 있는 반면, 창만큼 많은 위치 목록을 가질 수 있다는 것입니다.

두 개의 창이 열려 있고, 한 창은 `food.txt`를, 다른 창은 `drinks.txt`를 표시하고 있다고 가정해 봅시다. `food.txt` 내부에서 위치 목록 검색 명령어 `:lvimgrep`(`:vimgrep` 명령어의 위치 변형)을 실행합니다:

```
:lvim /bagel/ **/*.md
```

Vim은 해당 `food.txt` *창*에 대한 모든 베이글 검색 일치 항목의 위치 목록을 만듭니다. `:lopen`으로 위치 목록을 볼 수 있습니다. 이제 다른 창 `drinks.txt`로 가서 다음을 실행하세요:

```
:lvimgrep /milk/ **/*.md
```

Vim은 해당 `drinks.txt` *창*에 대한 모든 우유 검색 결과의 *별도* 위치 목록을 만듭니다.

각 창에서 실행하는 각 위치 명령어에 대해 Vim은 고유한 위치 목록을 만듭니다. 10개의 다른 창이 있다면, 최대 10개의 다른 위치 목록을 가질 수 있습니다. 이것을 언제든지 하나만 가질 수 있는 빠른 수정 목록과 대조해보세요. 10개의 다른 창이 있더라도, 여전히 하나의 빠른 수정 목록만 얻습니다.

대부분의 위치 목록 명령어는 `l-` 접두사가 붙는다는 점을 제외하고는 빠른 수정 명령어와 유사합니다. 예를 들어: `:lvimgrep`, `:lgrep`, `:lmake` 대 `:vimgrep`, `:grep`, `:make`. 위치 목록 창을 조작하려면, 다시, 명령어는 빠른 수정 명령어 `:lopen`, `:lclose`, `:lfirst`, `:llast`, `:lnext`, `:lprev` 대 `:copen`, `:cclose`, `:cfirst`, `:clast`, `:cnext`, `:cprev`와 유사해 보입니다.

두 개의 위치 목록 다중 파일 명령어 또한 빠른 수정 다중 파일 명령어와 유사합니다: `:ldo`와 `:lfdo`. `:ldo`는 각 위치 목록에서 위치 명령어를 실행하는 반면, `:lfdo`는 위치 목록의 각 파일에 대해 위치 목록 명령어를 실행합니다. 더 많은 정보는 `:h location-list`를 확인하세요.

## Vim에서 여러 파일 작업 실행하기

여러 파일 작업을 수행하는 방법을 아는 것은 편집에서 유용한 기술입니다. 여러 파일에 걸쳐 변수 이름을 변경해야 할 때, 한 번에 실행하고 싶을 것입니다. Vim에는 이를 수행할 수 있는 여덟 가지 다른 방법이 있습니다.

실질적으로, 아마도 여덟 가지 모두를 동등하게 사용하지는 않을 것입니다. 한두 가지에 끌리게 될 것입니다. 처음 시작할 때, 하나를 선택하여(저는 개인적으로 인수 목록 `:argdo`로 시작하는 것을 제안합니다) 마스터하세요. 하나에 익숙해지면, 다음 것을 배우세요. 두 번째, 세 번째, 네 번째를 배우는 것이 더 쉬워진다는 것을 알게 될 것입니다. 창의적으로 사용하세요. 다른 조합과 함께 사용하세요. 이것을 힘들이지 않고 생각 없이 할 수 있을 때까지 계속 연습하세요. 근육 기억의 일부로 만드세요.

그렇게 말하면서, 당신은 Vim 편집을 마스터했습니다. 축하합니다!