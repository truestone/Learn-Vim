# Ch07. 점(.) 명령어

일반적으로, 가능할 때마다 방금 했던 일을 반복하는 것을 피해야 합니다. 이 장에서는 이전 변경 사항을 쉽게 반복하기 위해 점 명령어를 사용하는 방법을 배웁니다. 이것은 간단한 반복을 줄이는 데 다재다능한 명령어입니다.

## 사용법

이름 그대로, 점 키(`.`)를 눌러 점 명령어를 사용할 수 있습니다.

예를 들어, 다음 표현식에서 모든 "let"을 "const"로 바꾸고 싶다면:

```
let one = "1";
let two = "2";
let three = "3";
```

- `/let`으로 검색하여 일치하는 곳으로 이동합니다.
- `cwconst<Esc>`로 변경하여 "let"을 "const"로 바꿉니다.
- `n`으로 이동하여 이전 검색을 사용하여 다음 일치 항목을 찾습니다.
- 점 명령어(`.`)로 방금 했던 일을 반복합니다.
- 모든 단어를 바꿀 때까지 `n . n .`을 계속 누릅니다.

여기서 점 명령어는 `cwconst<Esc>` 시퀀스를 반복했습니다. 단 한 번의 키 입력으로 여덟 번의 키 입력을 절약했습니다.

## 변경이란 무엇인가?

점 명령어의 정의(`:h .`)를 보면, 점 명령어가 마지막 변경을 반복한다고 나와 있습니다. 변경이란 무엇일까요?

현재 버퍼의 내용을 업데이트(추가, 수정 또는 삭제)할 때마다 변경을 하는 것입니다. 예외는 커맨드-라인 명령어( `:`로 시작하는 명령어)로 수행된 업데이트는 변경으로 간주되지 않는다는 것입니다.

첫 번째 예에서, `cwconst<Esc>`가 변경이었습니다. 이제 다음과 같은 텍스트가 있다고 가정해 봅시다:

```
pancake, potatoes, fruit-juice,
```

줄의 시작부터 쉼표의 다음 발생까지 텍스트를 삭제하려면, 먼저 쉼표까지 삭제한 다음 `df,..`로 두 번 반복합니다.

다른 예를 시도해 봅시다:

```
pancake, potatoes, fruit-juice,
```

이번에는 아침 식사 항목이 아니라 쉼표를 삭제하는 것이 과제입니다. 줄의 시작에 커서를 놓고, 첫 번째 쉼표로 이동하여 삭제한 다음, `f,x..`로 두 번 더 반복합니다. 쉽죠? 잠깐만요, 작동하지 않았습니다! 왜일까요?

변경은 버퍼 내용을 업데이트하지 않기 때문에 모션을 제외합니다. `f,x` 명령어는 두 가지 작업으로 구성되었습니다: 커서를 ","로 이동하는 `f,` 명령어와 문자를 삭제하는 `x`입니다. 후자인 `x`만이 변경을 일으켰습니다. 이전 예의 `df,`와 대조해 보세요. 그 안에서 `f,`는 커서를 이동하는 모션이 아니라 삭제 연산자 `d`에 대한 지시어입니다. `df,`와 `f,x`의 `f,`는 매우 다른 두 가지 역할을 합니다.

마지막 과제를 끝내 봅시다. `f,`를 실행한 다음 `x`를 실행한 후, 최신 `f`를 반복하기 위해 `;`로 다음 쉼표로 이동합니다. 마지막으로, `.`을 사용하여 커서 아래의 문자를 삭제합니다. 모든 것이 삭제될 때까지 `; . ; .`을 반복합니다. 전체 명령어는 `f,x;.;.`입니다.

다른 것을 시도해 봅시다:

```
pancake
potatoes
fruit-juice
```

각 줄의 끝에 쉼표를 추가해 봅시다. 첫 번째 줄에서 시작하여 `A,<Esc>j`를 수행합니다. 이제 `j`가 변경을 일으키지 않는다는 것을 깨달았을 것입니다. 여기서 변경은 `A,`뿐입니다. `j . j .`로 이동하고 변경을 반복할 수 있습니다. 전체 명령어는 `A,<Esc>j.j.`입니다.

삽입 명령어 연산자(`A`)를 누르는 순간부터 삽입 명령어(`<Esc>`)를 종료할 때까지의 모든 작업은 변경으로 간주됩니다.

## 여러 줄 반복

다음과 같은 텍스트가 있다고 가정해 봅시다:

```
let one = "1";
let two = "2";
let three = "3";
const foo = "bar';
let four = "4";
let five = "5";
let six = "6";
let seven = "7";
let eight = "8";
let nine = "9";
```

목표는 "foo" 줄을 제외한 모든 줄을 삭제하는 것입니다. 먼저 `d2j`로 처음 세 줄을 삭제한 다음, "foo" 줄 아래의 줄로 이동합니다. 다음 줄에서 점 명령어를 두 번 사용합니다. 전체 명령어는 `d2jj..`입니다.

여기서 변경은 `d2j`였습니다. 이 맥락에서 `2j`는 모션이 아니라 삭제 연산자의 일부였습니다.

다른 예를 살펴봅시다:

```
zlet zzone = "1";
zlet zztwo = "2";
zlet zzthree = "3";
let four = "4";
```

모든 z를 제거해 봅시다. 첫 번째 줄의 첫 문자에서 시작하여, 블록 단위 비주얼 모드(`Ctrl-Vjj`)로 처음 세 줄의 첫 번째 z만 시각적으로 선택합니다. 블록 단위 비주얼 모드에 익숙하지 않다면, 나중 장에서 다룰 것입니다. 세 개의 z를 시각적으로 선택했으면, 삭제 연산자(`d`)로 삭제합니다. 그런 다음 다음 단어(`w`)로 이동하여 다음 z로 이동합니다. 변경을 두 번 더 반복합니다(`..`). 전체 명령어는 `Ctrl-vjjdw..`입니다.

세 개의 z 열을 삭제했을 때(`Ctrl-vjjd`), 그것은 변경으로 계산되었습니다. 비주얼 모드 작업은 변경의 일부로 여러 줄을 대상으로 하는 데 사용할 수 있습니다.

## 변경에 모션 포함하기

이 장의 첫 번째 예로 돌아가 봅시다. `/letcwconst<Esc>` 명령어 다음에 `n . n .`을 사용하여 다음 표현식의 모든 "let"을 "const"로 바꿨던 것을 기억하세요:

```
let one = "1";
let two = "2";
let three = "3";
```

이것을 더 빨리 달성하는 방법이 있습니다. `/let`을 검색한 후, `cgnconst<Esc>`를 실행한 다음 `. .`을 실행하세요.

`gn`은 마지막 검색 패턴(이 경우, `/let`)을 앞으로 검색하고 자동으로 시각적 강조 표시를 하는 모션입니다. 다음 발생을 바꾸려면 더 이상 이동하고 변경을 반복할 필요가 없으며( `n . n .`), 반복만 하면 됩니다(`..`). 다음 일치 항목을 검색하는 것이 이제 변경의 일부가 되었기 때문에 더 이상 검색 모션을 사용할 필요가 없습니다!

편집할 때, 가능할 때마다 `gn`과 같이 한 번에 여러 가지를 할 수 있는 모션을 항상 찾아보세요.

## 현명하게 점 명령어 배우기

점 명령어의 힘은 여러 키 입력을 하나로 교환하는 데서 나옵니다. `x`와 같은 단일 키 작업에 점 명령어를 사용하는 것은 아마도 이익이 되는 교환이 아닐 것입니다. 마지막 변경이 `cgnconst<Esc>`와 같은 복잡한 작업을 필요로 한다면, 점 명령어는 아홉 번의 키 입력을 하나로 줄여주므로 매우 이익이 되는 절충안입니다.

편집할 때, 반복성에 대해 생각해보세요. 예를 들어, 다음 세 단어를 제거해야 한다면, `d3w`를 사용하는 것이 더 경제적일까요, 아니면 `dw`를 한 다음 `.`을 두 번 하는 것이 더 경제적일까요? 다시 단어를 삭제할 것인가요? 그렇다면, `d3w`보다 `dw`가 더 재사용 가능하기 때문에 `dw`를 사용하고 여러 번 반복하는 것이 합리적입니다.

점 명령어는 단일 변경을 자동화하는 데 다재다능한 명령어입니다. 나중 장에서는 Vim 매크로로 더 복잡한 작업을 자동화하는 방법을 배울 것입니다. 하지만 먼저, 텍스트를 저장하고 검색하기 위해 레지스터에 대해 배워봅시다.