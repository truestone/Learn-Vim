# Ch14. 외부 명령어

유닉스 시스템 내부에는 한 가지 일을 (그리고 잘) 하는 작고 매우 전문화된 많은 명령어들이 있습니다. 이러한 명령어들을 연결하여 복잡한 문제를 해결하기 위해 함께 작동하도록 할 수 있습니다. Vim 내부에서 이러한 명령어들을 사용할 수 있다면 좋지 않을까요?

물론입니다. 이 장에서는 Vim을 외부 명령어와 원활하게 작동하도록 확장하는 방법을 배웁니다.

## 느낌표(!) 명령어

Vim에는 세 가지를 할 수 있는 느낌표(`!`) 명령어가 있습니다:

1. 외부 명령어의 STDOUT을 현재 버퍼로 읽어들입니다.
2. 버퍼의 내용을 외부 명령어의 STDIN으로 작성합니다.
3. Vim 내부에서 외부 명령어를 실행합니다.

각각을 살펴보겠습니다.

## 명령어의 STDOUT을 Vim으로 읽어들이기

외부 명령어의 STDOUT을 현재 버퍼로 읽어들이는 구문은 다음과 같습니다:

```
:r !cmd
```

`:r`은 Vim의 읽기 명령어입니다. `!` 없이 사용하면 파일의 내용을 가져오는 데 사용할 수 있습니다. 현재 디렉토리에 `file1.txt` 파일이 있고 다음을 실행하면:

```
:r file1.txt
```

Vim은 `file1.txt`의 내용을 현재 버퍼에 넣습니다.

`:r` 명령어 뒤에 `!`와 외부 명령어를 실행하면, 해당 명령어의 출력이 현재 버퍼에 삽입됩니다. `ls` 명령어의 결과를 얻으려면 다음을 실행하세요:

```
:r !ls
```

다음과 같은 것을 반환합니다:

```
file1.txt
file2.txt
file3.txt
```

`curl` 명령어에서 데이터를 읽을 수 있습니다:

```
:r !curl -s 'https://jsonplaceholder.typicode.com/todos/1'
```

`r` 명령어는 주소도 받습니다:

```
:10r !cat file1.txt
```

이제 `cat file1.txt` 실행의 STDOUT이 10번 줄 뒤에 삽입됩니다.

## 버퍼 내용을 외부 명령어로 작성하기

`:w` 명령어는 파일을 저장하는 것 외에도, 현재 버퍼의 텍스트를 외부 명령어의 STDIN으로 전달하는 데 사용될 수 있습니다. 구문은 다음과 같습니다:

```
:w !cmd
```

다음과 같은 표현식이 있다면:

```
console.log("Hello Vim");
console.log("Vim is awesome");
```

컴퓨터에 [node](https://nodejs.org/en/)가 설치되어 있는지 확인한 다음, 다음을 실행하세요:

```
:w !node
```

Vim은 `node`를 사용하여 자바스크립트 표현식을 실행하여 "Hello Vim"과 "Vim is awesome"을 출력합니다.

`:w` 명령어를 사용할 때, Vim은 전역 명령어와 유사하게 현재 버퍼의 모든 텍스트를 사용합니다 (대부분의 커맨드-라인 명령어는 범위를 전달하지 않으면 현재 줄에 대해서만 명령어를 실행합니다). `:w`에 특정 주소를 전달하면:

```
:2w !node
```

Vim은 `node` 인터프리터에 두 번째 줄의 텍스트만 사용합니다.

`:w !node`와 `:w! node` 사이에는 미묘하지만 중요한 차이가 있습니다. `:w !node`를 사용하면 현재 버퍼의 텍스트를 외부 명령어 `node`에 "쓰는" 것입니다. `:w! node`를 사용하면 파일을 강제로 저장하고 파일 이름을 "node"로 지정하는 것입니다.

## 외부 명령어 실행하기

느낌표 명령어로 Vim 내부에서 외부 명령어를 실행할 수 있습니다. 구문은 다음과 같습니다:

```
:!cmd
```

현재 디렉토리의 내용을 긴 형식으로 보려면 다음을 실행하세요:

```
:!ls -ls
```

PID 3456에서 실행 중인 프로세스를 종료하려면 다음을 실행할 수 있습니다:

```
:!kill -9 3456
```

Vim을 떠나지 않고도 모든 외부 명령어를 실행할 수 있으므로 작업에 계속 집중할 수 있습니다.

## 텍스트 필터링하기

`!`에 범위를 지정하면 텍스트를 필터링하는 데 사용할 수 있습니다. 다음과 같은 텍스트가 있다고 가정해 봅시다:

```
hello vim
hello vim
```

`tr`(translate) 명령어를 사용하여 현재 줄을 대문자로 만들어 봅시다. 다음을 실행하세요:

```
:.!tr '[:lower:]' '[:upper:]'
```

결과:

```
HELLO VIM
hello vim
```

분석:
- `.!`는 현재 줄에서 필터 명령어를 실행합니다.
- `tr '[:lower:]' '[:upper:]'`는 모든 소문자를 대문자로 바꾸기 위해 `tr` 명령어를 호출합니다.

외부 명령어를 필터로 실행하려면 범위를 전달하는 것이 필수적입니다. `.` 없이 위 명령어를 실행하려고 하면(`:!tr '[:lower:]' '[:upper:]'`), 오류가 표시됩니다.

`awk` 명령어로 두 줄의 두 번째 열을 모두 제거해야 한다고 가정해 봅시다:

```
:%!awk "{print $1}"
```

결과:

```
hello
hello
```

분석:
- `:%!`는 모든 줄(`%`)에서 필터 명령어를 실행합니다.
- `awk "{print $1}"`는 일치하는 항목의 첫 번째 열만 출력합니다.

터미널에서처럼 체인 연산자(`|`)로 여러 명령어를 연결할 수 있습니다. 다음과 같은 맛있는 아침 식사 항목이 있는 파일이 있다고 가정해 봅시다:

```
name price
chocolate pancake 10
buttermilk pancake 9
blueberry pancake 12
```

가격을 기준으로 정렬하고 균일한 간격으로 메뉴만 표시해야 하는 경우, 다음을 실행할 수 있습니다:

```
:%!awk 'NR > 1' | sort -nk 3 | column -t
```

결과:
```
buttermilk pancake 9
chocolate pancake 10
blueberry pancake 12
```

분석:
- `:%!`는 모든 줄(`%`)에 필터를 적용합니다.
- `awk 'NR > 1'`는 2번 행부터 텍스트를 표시합니다.
- `|`는 다음 명령어를 연결합니다.
- `sort -nk 3`는 3번 열(`k 3`)의 값을 사용하여 숫자적으로(`n`) 정렬합니다.
- `column -t`는 균일한 간격으로 텍스트를 구성합니다.

## 일반 모드 명령어

Vim에는 일반 모드에 필터 연산자(`!`)가 있습니다. 다음과 같은 인사가 있다면:

```
hello vim
hola vim
bonjour vim
salve vim
```

현재 줄과 그 아래 줄을 대문자로 만들려면 다음을 실행할 수 있습니다:
```
!jtr '[a-z]' '[A-Z]'
```

분석:
- `!j`는 현재 줄과 그 아래 줄을 대상으로 하는 일반 명령어 필터 연산자(`!`)를 실행합니다. 이것이 일반 모드 연산자이므로, 문법 규칙 `동사 + 명사`가 적용된다는 것을 상기하세요. `!`는 동사이고 `j`는 명사입니다.
- `tr '[a-z]' '[A-Z]'`는 소문자를 대문자로 바꿉니다.

필터 일반 명령어는 적어도 한 줄 이상의 모션/텍스트 객체에서만 작동합니다. `!iwtr '[a-z]' '[A-Z]'`(내부 단어에서 `tr` 실행)를 실행하려고 했다면, 커서가 있는 단어가 아닌 전체 줄에 `tr` 명령어가 적용되는 것을 발견할 것입니다.

## 현명하게 외부 명령어 배우기

Vim은 IDE가 아닙니다. 디자인상 고도로 확장 가능한 경량 모달 편집기입니다. 이러한 확장성 덕분에 시스템의 모든 외부 명령어에 쉽게 접근할 수 있습니다. 이러한 외부 명령어로 무장하면, Vim은 IDE가 되는 데 한 걸음 더 가까워집니다. 누군가는 유닉스 시스템이 최초의 IDE라고 말했습니다.

느낌표 명령어는 여러분이 아는 외부 명령어 수만큼 유용합니다. 외부 명령어 지식이 제한적이라고 걱정하지 마세요. 저도 아직 배울 것이 많습니다. 이것을 지속적인 학습의 동기로 삼으세요. 텍스트를 수정해야 할 때마다, 문제를 해결할 수 있는 외부 명령어가 있는지 찾아보세요. 모든 것을 마스터하는 것에 대해 걱정하지 말고, 현재 작업을 완료하는 데 필요한 것만 배우세요.