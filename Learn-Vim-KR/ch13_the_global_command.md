# Ch13. 전역 명령어

지금까지 점 명령어(`.`)로 마지막 변경을 반복하고, 매크로(`q`)로 동작을 재현하고, 레지스터(`"`)에 텍스트를 저장하는 방법을 배웠습니다.

이 장에서는 전역 명령어로 커맨드-라인 명령어를 반복하는 방법을 배웁니다.

## 전역 명령어 개요

Vim의 전역 명령어는 여러 줄에 걸쳐 동시에 커맨드-라인 명령어를 실행하는 데 사용됩니다.

그런데, 이전에 "Ex 명령어"라는 용어를 들어보셨을 수도 있습니다. 이 가이드에서는 이를 커맨드-라인 명령어라고 부릅니다. Ex 명령어와 커맨드-라인 명령어는 모두 같습니다. 콜론(`:`)으로 시작하는 명령어입니다. 지난 장의 치환 명령어는 Ex 명령어의 한 예였습니다. 원래 Ex 텍스트 편집기에서 유래했기 때문에 Ex라고 불립니다. 이 가이드에서는 계속해서 커맨드-라인 명령어라고 부르겠습니다. Ex 명령어의 전체 목록은 `:h ex-cmd-index`를 확인하세요.

전역 명령어는 다음과 같은 구문을 가집니다:

```
:g/pattern/command
```

패턴은 치환 명령어의 패턴과 유사하게 해당 패턴을 포함하는 모든 줄과 일치합니다. 명령어는 모든 커맨드-라인 명령어가 될 수 있습니다. 전역 명령어는 패턴과 일치하는 각 줄에 대해 `command`를 실행함으로써 작동합니다.

다음과 같은 표현식이 있다면:

```
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
```

"console"을 포함하는 모든 줄을 제거하려면 다음을 실행할 수 있습니다:

```
:g/console/d
```

결과:

```
const one = 1;

const two = 2;

const three = 3;
```

전역 명령어는 "console" 패턴과 일치하는 모든 줄에서 삭제 명령어(`d`)를 실행합니다.

`g` 명령어를 실행할 때, Vim은 파일을 두 번 스캔합니다. 첫 번째 실행에서, 각 줄을 스캔하고 `/console/` 패턴과 일치하는 줄을 표시합니다. 모든 일치하는 줄이 표시되면, 두 번째로 이동하여 표시된 줄에서 `d` 명령어를 실행합니다.

대신 "const"를 포함하는 모든 줄을 삭제하려면 다음을 실행하세요:

```
:g/const/d
```

결과:

```
console.log("one: ", one);

console.log("two: ", two);

console.log("three: ", three);
```

## 반전 일치

일치하지 않는 줄에서 전역 명령어를 실행하려면 다음을 실행할 수 있습니다:

```
:g!/pattern/command
```

또는

```
:v/pattern/command
```

`:v/console/d`를 실행하면 "console"을 포함하지 *않는* 모든 줄이 삭제됩니다.

## 패턴

전역 명령어는 치환 명령어와 동일한 패턴 시스템을 사용하므로, 이 섹션은 복습 역할을 합니다. 다음 섹션으로 건너뛰거나 함께 읽어보세요!

다음과 같은 표현식이 있다면:

```
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
```

"one" 또는 "two"를 포함하는 줄을 삭제하려면 다음을 실행하세요:

```
:g/one\|two/d
```

단일 숫자를 포함하는 줄을 삭제하려면 다음 중 하나를 실행하세요:

```
:g/[0-9]/d
```

또는

```
:g/\d/d
```

다음과 같은 표현식이 있다면:

```
const oneMillion = 1000000;
const oneThousand = 1000;
const one = 1;
```

3개에서 6개의 0을 포함하는 줄을 일치시키려면 다음을 실행하세요:

```
:g/0\{3,6\}/d
```

## 범위 전달하기

`g` 명령어 앞에 범위를 전달할 수 있습니다. 다음과 같은 몇 가지 방법이 있습니다:
- `:1,5g/console/d`는 1번 줄과 5번 줄 사이에서 "console" 문자열을 일치시키고 삭제합니다.
- `:,5g/console/d` 쉼표 앞에 주소가 없으면 현재 줄에서 시작합니다. 현재 줄과 5번 줄 사이에서 "console" 문자열을 찾아 삭제합니다.
- `:3,g/console/d` 쉼표 뒤에 주소가 없으면 현재 줄에서 끝납니다. 3번 줄과 현재 줄 사이에서 "console" 문자열을 찾아 삭제합니다.
- `:3g/console/d` 쉼표 없이 하나의 주소만 전달하면 해당 줄에서만 명령어를 실행합니다. 3번 줄을 보고 "console" 문자열이 있으면 삭제합니다.

숫자 외에도 다음 기호를 범위로 사용할 수 있습니다:
- `.`는 현재 줄을 의미합니다. `.,3` 범위는 현재 줄과 3번 줄 사이를 의미합니다.
- `$`는 파일의 마지막 줄을 의미합니다. `3,$` 범위는 3번 줄과 마지막 줄 사이를 의미합니다.
- `+n`은 현재 줄 뒤의 n번째 줄을 의미합니다. `.`와 함께 또는 없이 사용할 수 있습니다. `3,+1` 또는 `3,.+1`은 3번 줄과 현재 줄 다음 줄 사이를 의미합니다.

범위를 지정하지 않으면 기본적으로 전체 파일에 영향을 미칩니다. 이것은 사실 일반적인 경우가 아닙니다. 대부분의 Vim 커맨드-라인 명령어는 범위를 전달하지 않으면 현재 줄에서만 실행됩니다. 두 가지 주목할 만한 예외는 전역(`:g`) 및 저장(`:w`) 명령어입니다.

## 일반 명령어

`:normal` 커맨드-라인 명령어로 전역 명령어로 일반 명령어를 실행할 수 있습니다.

다음과 같은 텍스트가 있다면:
```
const one = 1
console.log("one: ", one)

const two = 2
console.log("two: ", two)

const three = 3
console.log("three: ", three)
```

각 줄 끝에 ";"를 추가하려면 다음을 실행하세요:

```
:g/./normal A;
```

분석해 봅시다:
- `:g`는 전역 명령어입니다.
- `/./`는 "비어 있지 않은 줄"에 대한 패턴입니다. 적어도 하나의 문자가 있는 줄과 일치하므로 "const"와 "console"이 있는 줄과 일치하고 빈 줄과는 일치하지 않습니다.
- `normal A;`는 `:normal` 커맨드-라인 명령어를 실행합니다. `A;`는 줄 끝에 ";"를 삽입하는 일반 모드 명령어입니다.

## 매크로 실행하기

전역 명령어로 매크로를 실행할 수도 있습니다. 매크로는 `normal` 명령어로 실행할 수 있습니다. 다음과 같은 표현식이 있다면:

```
const one = 1
console.log("one: ", one);

const two = 2
console.log("two: ", two);

const three = 3
console.log("three: ", three);
```

"const"가 있는 줄에는 세미콜론이 없습니다. a 레지스터에 해당 줄 끝에 쉼표를 추가하는 매크로를 만들어 봅시다:

```
qaA;<Esc>q
```

복습이 필요하다면 매크로에 대한 장을 확인하세요. 이제 다음을 실행하세요:

```
:g/const/normal @a
```

이제 "const"가 있는 모든 줄 끝에 ";"가 생깁니다.

```
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
```

이 단계를 단계별로 따랐다면 첫 번째 줄에 두 개의 세미콜론이 생길 것입니다. 그것을 피하려면 두 번째 줄부터 전역 명령어를 실행하세요: `:2,$g/const/normal @a`.

## 재귀적 전역 명령어

전역 명령어 자체는 커맨드-라인 명령어의 한 유형이므로, 기술적으로 전역 명령어 안에서 전역 명령어를 실행할 수 있습니다.

다음 표현식이 주어졌을 때, 두 번째 `console.log` 문을 삭제하고 싶다면:

```
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
```

다음을 실행하면:

```
:g/console/g/two/d
```

먼저, `g`는 "console" 패턴을 포함하는 줄을 찾아 3개의 일치 항목을 찾습니다. 그런 다음 두 번째 `g`는 그 세 개의 일치 항목에서 "two" 패턴을 포함하는 줄을 찾습니다. 마지막으로, 해당 일치 항목을 삭제합니다.

`g`와 `v`를 결합하여 긍정 및 부정 패턴을 찾을 수도 있습니다. 예를 들어:

```
:g/console/v/two/d
```

"two" 패턴을 포함하는 줄을 찾는 대신, "two" 패턴을 포함하지 *않는* 줄을 찾습니다.

## 구분 기호 변경하기

치환 명령어처럼 전역 명령어의 구분 기호를 변경할 수 있습니다. 규칙은 동일합니다: 알파벳, 숫자, `"`, `|`, `\`를 제외한 모든 단일 바이트 문자를 사용할 수 있습니다.

"console"을 포함하는 줄을 삭제하려면:

```
:g@console@d
```

전역 명령어로 치환 명령어를 사용하는 경우, 두 개의 다른 구분 기호를 가질 수 있습니다:

```
g@one@s+const+let+g
```

여기서 전역 명령어는 "one"을 포함하는 모든 줄을 찾습니다. 치환 명령어는 해당 일치 항목에서 "const" 문자열을 "let"으로 치환합니다.

## 기본 명령어

전역 명령어에 커맨드-라인 명령어를 지정하지 않으면 어떻게 될까요?

전역 명령어는 현재 줄의 텍스트를 인쇄하기 위해 인쇄(`:p`) 명령어를 사용합니다. 다음을 실행하면:

```
:g/console
```

화면 하단에 "console"을 포함하는 모든 줄이 인쇄됩니다.

그런데, 흥미로운 사실이 하나 있습니다. 전역 명령어가 사용하는 기본 명령어가 `p`이기 때문에, `g` 구문은 다음과 같습니다:

```
:g/re/p
```

- `g` = 전역 명령어
- `re` = 정규식 패턴
- `p` = 인쇄 명령어

이것은 *"grep"*, 즉 커맨드 라인의 `grep`과 같습니다. 이것은 **우연이 아닙니다**. `g/re/p` 명령어는 원래 최초의 라인 텍스트 편집기 중 하나인 Ed Editor에서 유래했습니다. `grep` 명령어는 Ed에서 그 이름을 얻었습니다.

컴퓨터에 아직 Ed 편집기가 있을 것입니다. 터미널에서 `ed`를 실행하세요 (힌트: 종료하려면 `q`를 입력).

## 전체 버퍼 뒤집기

전체 파일을 뒤집으려면 다음을 실행하세요:

```
:g/^/m 0
```

`^`는 줄의 시작에 대한 패턴입니다. 빈 줄을 포함한 모든 줄을 일치시키려면 `^`를 사용하세요.

몇 줄만 뒤집어야 하는 경우, 범위를 전달하세요. 5번 줄부터 10번 줄까지 뒤집으려면 다음을 실행하세요:

```
:5,10g/^/m 0
```

이동 명령어에 대해 더 배우려면 `:h :move`를 확인하세요.

## 모든 TODO 집계하기

코딩할 때, 때때로 편집 중인 파일에 TODO를 작성합니다:

```
const one = 1;
console.log("one: ", one);
// TODO: feed the puppy

const two = 2;
// TODO: feed the puppy automatically
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
// TODO: create a startup selling an automatic puppy feeder
```

생성된 모든 TODO를 추적하기 어려울 수 있습니다. Vim에는 모든 일치 항목을 주소로 복사하는 `:t`(복사) 메소드가 있습니다. 복사 메소드에 대해 더 배우려면 `:h :copy`를 확인하세요.

더 쉬운 성찰을 위해 모든 TODO를 파일 끝으로 복사하려면 다음을 실행하세요:

```
:g/TODO/t $
```

결과:

```
const one = 1;
console.log("one: ", one);
// TODO: feed the puppy

const two = 2;
// TODO: feed the puppy automatically
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
// TODO: create a startup selling an automatic puppy feeder

// TODO: feed the puppy
// TODO: feed the puppy automatically
// TODO: create a startup selling an automatic puppy feeder
```

이제 생성한 모든 TODO를 검토하고, 그것들을 할 시간을 찾거나 다른 사람에게 위임하고, 다음 작업에 계속 집중할 수 있습니다.

복사하는 대신 모든 TODO를 끝으로 이동하고 싶다면, 이동 명령어 `:m`을 사용하세요:

```
:g/TODO/m $
```

결과:

```
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);

// TODO: feed the puppy
// TODO: feed the puppy automatically
// TODO: create a startup selling an automatic puppy feeder
```

## 블랙홀 삭제

레지스터 장에서 삭제된 텍스트는 번호 매겨진 레지스터에 저장된다는 것을 상기하세요(충분히 크다면). `:g/console/d`를 실행할 때마다 Vim은 삭제된 줄을 번호 매겨진 레지스터에 저장합니다. 많은 줄을 삭제하면 모든 번호 매겨진 레지스터를 빠르게 채울 수 있습니다. 이를 피하기 위해, 항상 블랙홀 레지스터(`"_"`)를 사용하여 삭제된 줄을 레지스터에 저장하지 *않도록* 할 수 있습니다. 다음을 실행하세요:

```
:g/console/d_
```

`d` 뒤에 `_`를 전달하면 Vim은 스크래치 레지스터를 사용하지 않습니다.

## 여러 빈 줄을 하나의 빈 줄로 줄이기

여러 빈 줄이 있는 텍스트가 있다면:

```
const one = 1;
console.log("one: ", one);


const two = 2;
console.log("two: ", two);





const three = 3;
console.log("three: ", three);
```

다음으로 빈 줄을 하나의 빈 줄로 빠르게 줄일 수 있습니다:

```
:g/^$/,/./-1j
```

결과:

```
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
```

일반적으로 전역 명령어는 `:g/pattern/command` 형식을 따릅니다. 하지만, `:g/pattern1/,/pattern2/command` 형식으로 전역 명령어를 실행할 수도 있습니다. 이것으로, Vim은 `pattern1`과 `pattern2` 내에서 `command`를 적용합니다.

그 점을 염두에 두고, `:g/^$/,/./-1j` 명령어를 `:g/pattern1/,/pattern2/command`에 따라 분석해 봅시다:
- `/pattern1/`은 `/^$/`입니다. 빈 줄(0개의 문자가 있는 줄)을 나타냅니다.
- `/pattern2/`는 `-1` 줄 수정자가 있는 `/./`입니다. `/./`는 비어 있지 않은 줄(적어도 하나의 문자가 있는 줄)을 나타냅니다. `-1`은 그 위의 줄을 의미합니다.
- `command`는 결합 명령어(`:j`)인 `j`입니다. 이 맥락에서, 이 전역 명령어는 주어진 모든 줄을 결합합니다.

그런데, 여러 빈 줄을 빈 줄 없음으로 줄이고 싶다면, 대신 이것을 실행하세요:

```
:g/^$/,/./j
```

더 간단한 대안:

```
:g/^$/-j
```

이제 텍스트는 다음과 같이 줄어듭니다:

```
const one = 1;
console.log("one: ", one);
const two = 2;
console.log("two: ", two);
const three = 3;
console.log("three: ", three);
```

## 고급 정렬

Vim에는 범위 내의 줄을 정렬하는 `:sort` 명령어가 있습니다. 예를 들어:

```
d
b
a
e
c
```

`:sort`를 실행하여 정렬할 수 있습니다. 범위를 지정하면 해당 범위 내의 줄만 정렬합니다. 예를 들어, `:3,5sort`는 3번과 5번 줄만 정렬합니다.

다음과 같은 표현식이 있다면:

```
const arrayB = [
  "i",
  "g",
  "h",
  "b",
  "f",
  "d",
  "e",
  "c",
  "a",
]

const arrayA = [
  "h",
  "b",
  "f",
  "d",
  "e",
  "a",
  "c",
]
```

배열 자체는 정렬하지 않고 배열 안의 요소만 정렬해야 한다면, 다음을 실행할 수 있습니다:

```
:g/\[/+1,/\]/-1sort
```

결과:

```
const arrayB = [
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
]

const arrayA = [
  "a"
  "b",
  "c",
  "d",
  "e",
  "f",
  "h",
]
```

이것은 훌륭합니다! 하지만 명령어가 복잡해 보입니다. 분석해 봅시다. 이 명령어 또한 `:g/pattern1/,/pattern2/command` 형식을 따릅니다.

- `:g`는 전역 명령어 패턴입니다.
- `/\[/+1`은 첫 번째 패턴입니다. 리터럴 왼쪽 대괄호 "["와 일치합니다. `+1`은 그 아래 줄을 참조합니다.
- `/\]/-1`은 두 번째 패턴입니다. 리터럴 오른쪽 대괄호 "]"와 일치합니다. `-1`은 그 위 줄을 참조합니다.
- `/\[/+1,/\]/-1`은 "["와 "]" 사이의 모든 줄을 참조합니다.
- `sort`는 정렬하는 커맨드-라인 명령어입니다.

## 현명하게 전역 명령어 배우기

전역 명령어는 일치하는 모든 줄에 대해 커맨드-라인 명령어를 실행합니다. 그것으로, 한 번만 명령어를 실행하면 Vim이 나머지를 알아서 해줍니다. 전역 명령어에 능숙해지려면 두 가지가 필요합니다: 커맨드-라인 명령어에 대한 좋은 어휘력과 정규 표현식에 대한 지식입니다. Vim을 더 많이 사용하면서 자연스럽게 더 많은 커맨드-라인 명령어를 배우게 될 것입니다. 정규 표현식 지식은 더 적극적인 접근 방식이 필요합니다. 하지만 정규 표현식에 익숙해지면, 많은 사람들보다 앞서게 될 것입니다.

여기의 몇 가지 예는 복잡합니다. 위축되지 마세요. 그것들을 이해하는 데 정말로 시간을 투자하세요. 패턴을 읽는 법을 배우세요. 포기하지 마세요.

여러 명령어를 실행해야 할 때마다, 잠시 멈추고 `g` 명령어를 사용할 수 있는지 확인하세요. 작업에 가장 적합한 명령어를 식별하고 한 번에 많은 것을 대상으로 하는 패턴을 작성하세요.

이제 전역 명령어가 얼마나 강력한지 알았으니, 도구 무기고를 늘리기 위해 외부 명령어를 사용하는 방법을 배워봅시다.