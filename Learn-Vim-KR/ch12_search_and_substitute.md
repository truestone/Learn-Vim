# Ch12. 검색과 치환

이 장에서는 두 가지 개별적이지만 관련된 개념인 검색과 치환을 다룹니다. 편집할 때, 종종 가장 덜 공통적인 분모 패턴을 기반으로 여러 텍스트를 검색해야 합니다. 리터럴 문자열 대신 검색 및 치환에서 정규 표현식을 사용하는 방법을 배우면 모든 텍스트를 빠르게 타겟팅할 수 있습니다.

참고로, 이 장에서는 검색에 대해 이야기할 때 `/`를 사용할 것입니다. `/`로 할 수 있는 모든 것은 `?`로도 할 수 있습니다.

## 스마트한 대소문자 구분

검색어의 대소문자를 맞추려고 하는 것은 까다로울 수 있습니다. "Learn Vim"이라는 텍스트를 검색하는 경우, 한 글자의 대소문자를 쉽게 잘못 입력하여 잘못된 검색 결과를 얻을 수 있습니다. 어떤 대소문자든 일치시킬 수 있다면 더 쉽고 안전하지 않을까요? 이것이 `ignorecase` 옵션이 빛을 발하는 곳입니다. vimrc에 `set ignorecase`를 추가하기만 하면 모든 검색어가 대소문자를 구분하지 않게 됩니다. 이제 더 이상 `/Learn Vim`을 할 필요 없이, `/learn vim`이 작동할 것입니다.

하지만, 대소문자를 구분하는 구문을 검색해야 할 때가 있습니다. 한 가지 방법은 `set noignorecase`를 실행하여 `ignorecase` 옵션을 끄는 것이지만, 대소문자를 구분하는 구문을 검색해야 할 때마다 켜고 끄는 것은 많은 작업입니다.

`ignorecase`를 토글하는 것을 피하기 위해, Vim에는 검색 패턴에 *적어도 하나의 대문자*가 포함된 경우 대소문자를 구분하지 않는 문자열을 검색하는 `smartcase` 옵션이 있습니다. `ignorecase`와 `smartcase`를 모두 결합하여 모든 소문자를 입력할 때 대소문자를 구분하지 않는 검색을 수행하고, 하나 이상의 대문자를 입력할 때 대소문자를 구분하는 검색을 수행할 수 있습니다.

vimrc 안에 다음을 추가하세요:

```
set ignorecase smartcase
```

다음과 같은 텍스트가 있다면:

```
hello
HELLO
Hello
```

- `/hello`는 "hello", "HELLO", "Hello"와 일치합니다.
- `/HELLO`는 "HELLO"와만 일치합니다.
- `/Hello`는 "Hello"와만 일치합니다.

한 가지 단점이 있습니다. 소문자 문자열만 검색해야 한다면 어떨까요? `/hello`를 하면, Vim은 이제 대소문자를 구분하지 않는 검색을 합니다. 검색어 어디에나 `\C` 패턴을 사용하여 Vim에게 후속 검색어가 대소문자를 구분할 것임을 알릴 수 있습니다. `/\Chello`를 하면, "HELLO"나 "Hello"가 아닌 "hello"와 엄격하게 일치합니다.

## 줄의 첫 문자와 마지막 문자

`^`를 사용하여 줄의 첫 문자를 일치시키고 `$`를 사용하여 줄의 마지막 문자를 일치시킬 수 있습니다.

다음과 같은 텍스트가 있다면:

```
hello hello
```

`/^hello`로 첫 번째 "hello"를 타겟팅할 수 있습니다. `^` 뒤에 오는 문자는 줄의 첫 문자여야 합니다. 마지막 "hello"를 타겟팅하려면 `/hello$`를 실행하세요. `$` 앞의 문자는 줄의 마지막 문자여야 합니다.

다음과 같은 텍스트가 있다면:

```
hello hello friend
```

`/hello$`를 실행하면 "friend"가 해당 줄의 마지막 용어이지 "hello"가 아니기 때문에 아무것도 일치하지 않습니다.

## 검색 반복하기

`//`로 이전 검색을 반복할 수 있습니다. 방금 `/hello`를 검색했다면, `//`를 실행하는 것은 `/hello`를 실행하는 것과 같습니다. 이 단축키는 특히 긴 문자열을 방금 검색한 경우 일부 키 입력을 절약할 수 있습니다. 또한 `n`과 `N`을 사용하여 각각 같은 방향과 반대 방향으로 마지막 검색을 반복할 수 있다는 것을 상기하세요.

*n*번째 마지막 검색어를 빠르게 회상하고 싶다면 어떨까요? 먼저 `/`를 누른 다음, 필요한 검색어를 찾을 때까지 위/아래 화살표 키(또는 `Ctrl-N`/`Ctrl-P`)를 눌러 검색 기록을 빠르게 탐색할 수 있습니다. 모든 검색 기록을 보려면 `:history /`를 실행할 수 있습니다.

검색 중에 파일의 끝에 도달하면 Vim은 "*Search hit the BOTTOM without match for: {your-search}*"라는 오류를 발생시킵니다. 때로는 이것이 과도한 검색을 방지하는 좋은 안전 장치가 될 수 있지만, 다른 때에는 검색을 다시 맨 위로 순환시키고 싶을 수 있습니다. `set wrapscan` 옵션을 사용하여 파일의 끝에 도달했을 때 Vim이 파일의 맨 위에서 다시 검색하도록 할 수 있습니다. 이 기능을 끄려면 `set nowrapscan`을 하세요.

## 대체 단어 검색하기

한 번에 여러 단어를 검색하는 것은 일반적입니다. "hello vim" 또는 "hola vim" 중 *하나*를 검색해야 하지만, "salve vim"이나 "bonjour vim"은 검색하고 싶지 않다면, `|` 패턴을 사용할 수 있습니다.

다음 텍스트가 주어졌을 때:

```
hello vim
hola vim
salve vim
bonjour vim
```

"hello"와 "hola"를 모두 일치시키려면, `/hello\|hola`를 할 수 있습니다. or (`|`) 연산자를 이스케이프(`\`)해야 합니다. 그렇지 않으면 Vim은 문자 그대로 "|" 문자열을 검색합니다.

매번 `\|`를 입력하고 싶지 않다면, 검색 시작 부분에 `magic` 구문(`\v`)을 사용할 수 있습니다: `/\vhello|hola`. 이 가이드에서는 `magic`을 다루지 않겠지만, `\v`를 사용하면 더 이상 특수 문자를 이스케이프할 필요가 없습니다. `\v`에 대해 더 배우려면 `:h \v`를 자유롭게 확인하세요.

## 일치의 시작과 끝 설정하기

복합 단어의 일부인 텍스트를 검색해야 할 수도 있습니다. 다음과 같은 텍스트가 있다면:

```
11vim22
vim22
11vim
vim
```

"11"로 시작하고 "22"로 끝나는 경우에만 "vim"을 선택해야 한다면, `\zs`(일치 시작) 및 `\ze`(일치 종료) 연산자를 사용할 수 있습니다. 다음을 실행하세요:

```
/11\zsvim\ze22
```

Vim은 여전히 전체 패턴 "11vim22"와 일치해야 하지만, `\zs`와 `\ze` 사이에 끼인 패턴만 강조 표시합니다. 다른 예:

```
foobar
foobaz
```

"foobaz"의 "foo"는 일치시키고 "foobar"의 "foo"는 일치시키지 않으려면 다음을 실행하세요:

```
/foo\zebaz
```

## 문자 범위 검색하기

지금까지의 모든 검색어는 리터럴 단어 검색이었습니다. 실제 생활에서는 텍스트를 찾기 위해 일반적인 패턴을 사용해야 할 수도 있습니다. 가장 기본적인 패턴은 문자 범위 `[ ]`입니다.

모든 숫자를 검색해야 하는 경우, 매번 `/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0`을 입력하고 싶지는 않을 것입니다. 대신, `/[0-9]`를 사용하여 단일 숫자를 일치시킵니다. `0-9` 표현식은 Vim이 일치시키려고 시도하는 0-9 숫자 범위를 나타내므로, 대신 1에서 5 사이의 숫자를 찾고 있다면 `/[1-5]`를 사용하세요.

Vim이 조회할 수 있는 데이터 유형은 숫자뿐만이 아닙니다. `/[a-z]`를 사용하여 소문자 알파벳을, `/[A-Z]`를 사용하여 대문자 알파벳을 검색할 수도 있습니다.

이러한 범위를 함께 결합할 수 있습니다. 0-9 숫자와 "a"에서 "f"까지의 소문자 및 대문자 알파벳(예: 16진수)을 모두 검색해야 하는 경우, `/[0-9a-fA-F]`를 할 수 있습니다.

부정 검색을 하려면 문자 범위 대괄호 안에 `^`를 추가할 수 있습니다. 숫자가 아닌 문자를 검색하려면 `/[^0-9]`를 실행하세요. Vim은 숫자가 아닌 한 모든 문자와 일치합니다. 범위 대괄호 안의 캐럿(`^`)은 줄 시작 캐럿(예: `/^hello`)과 다릅니다. 캐럿이 대괄호 쌍 외부에 있고 검색어의 첫 문자이면 "줄의 첫 문자"를 의미합니다. 캐럿이 대괄호 쌍 안에 있고 대괄호 안의 첫 문자이면 부정 검색 연산자를 의미합니다. `/^abc`는 줄의 첫 "abc"와 일치하고 `/[^abc]`는 "a", "b", "c"를 제외한 모든 문자와 일치합니다.

## 반복되는 문자 검색하기

다음 텍스트에서 두 자리 숫자를 검색해야 하는 경우:

```
1aa
11a
111
```

두 자리 문자를 일치시키기 위해 `/[0-9][0-9]`를 사용할 수 있지만, 이 방법은 확장성이 없습니다. 스무 자리 숫자를 일치시켜야 한다면 어떨까요? `[0-9]`를 스무 번 입력하는 것은 즐거운 경험이 아닙니다. 그래서 `count` 인수가 필요합니다.

검색에 `count`를 전달할 수 있습니다. 다음과 같은 구문을 가집니다:

```
{n,m}
```

참고로, 이러한 `count` 중괄호는 Vim에서 사용할 때 이스케이프해야 합니다. `count` 연산자는 증가시키려는 단일 문자 뒤에 배치됩니다.

다음은 `count` 구문의 네 가지 다른 변형입니다:
- `{n}`은 정확한 일치입니다. `/[0-9]\{2\}`는 두 자리 숫자 "11"과 "111"의 "11"과 일치합니다.
- `{n,m}`은 범위 일치입니다. `/[0-9]\{2,3\}`은 2자리와 3자리 숫자 사이의 숫자 "11"과 "111"과 일치합니다.
- `{\,m}`은 최대 일치입니다. `/[0-9]\{,3\}`은 최대 3자리 숫자 "1", "11", "111"과 일치합니다.
- `{n,\}`은 최소 일치입니다. `/[0-9]\{2,\}`는 최소 2자리 이상의 숫자 "11"과 "111"과 일치합니다.

`\{0,\}`(0개 이상) 및 `\{1,\}`(1개 이상) count 인수는 일반적인 검색 패턴이며 Vim에는 이에 대한 특수 연산자 `*` 및 `+`가 있습니다(`+`는 이스케이프해야 하지만 `*`는 이스케이프 없이 잘 작동합니다). `/[0-9]*`를 하면, `/[0-9]\{0,\}`와 같습니다. 0개 이상의 숫자를 검색합니다. "", "1", "123"과 일치합니다. 참고로, "a"와 같은 숫자가 아닌 문자도 일치합니다. 왜냐하면 문자 "a"에는 기술적으로 0개의 숫자가 있기 때문입니다. `*`를 사용하기 전에 신중하게 생각하세요. `/[0-9]\+`를 하면, `/[0-9]\{1,\}`와 같습니다. 1개 이상의 숫자를 검색합니다. "1"과 "12"와 일치합니다.

## 미리 정의된 문자 범위

Vim에는 숫자 및 알파벳과 같은 일반적인 문자에 대한 미리 정의된 범위가 있습니다. 여기서는 모든 것을 다루지 않겠지만, `:h /character-classes`에서 전체 목록을 찾을 수 있습니다. 다음은 유용한 것들입니다:

```
\d    숫자 [0-9]
\D    숫자가 아닌 문자 [^0-9]
\s    공백 문자 (스페이스 및 탭)
\S    공백이 아닌 문자 (스페이스 및 탭 제외 모든 것)
\w    단어 문자 [0-9A-Za-z_]
\l    소문자 알파벳 [a-z]
\u    대문자 문자 [A-Z]
```

문자 범위처럼 사용할 수 있습니다. 단일 숫자를 검색하려면 `/[0-9]` 대신 `/\d`를 사용하여 더 간결한 구문을 사용할 수 있습니다.

## 검색 예: 유사한 문자 쌍 사이의 텍스트 캡처하기

한 쌍의 큰따옴표로 둘러싸인 구문을 검색하려면:

```
"Vim is awesome!"
```

다음을 실행하세요:

```
/"[^"]\+"
```

분석해 봅시다:
- `"`는 리터럴 큰따옴표입니다. 첫 번째 큰따옴표와 일치합니다.
- `[^"]`는 큰따옴표를 제외한 모든 문자를 의미합니다. 큰따옴표가 아닌 한 모든 영숫자 및 공백 문자와 일치합니다.
- `\+`는 하나 이상을 의미합니다. `[^"]`가 앞에 오므로, Vim은 큰따옴표가 아닌 하나 이상의 문자를 찾습니다.
- `"`는 리터럴 큰따옴표입니다. 닫는 큰따옴표와 일치합니다.

Vim이 첫 번째 `"`를 보면, 패턴 캡처를 시작합니다. 줄에서 두 번째 큰따옴표를 보는 순간, 두 번째 `"` 패턴과 일치하고 패턴 캡처를 중지합니다. 한편, 그 사이의 모든 큰따옴표가 아닌 문자는 `[^"]\+` 패턴에 의해 캡처됩니다. 이 경우, `Vim is awesome!` 구문입니다. 이것은 한 쌍의 유사한 구분 기호로 둘러싸인 구문을 캡처하는 일반적인 패턴입니다.

- 작은따옴표로 둘러싸인 구문을 캡처하려면 `/'[^']\+'`를 사용할 수 있습니다.
- 0으로 둘러싸인 구문을 캡처하려면 `/0[^0]\+0`을 사용할 수 있습니다.

## 검색 예: 전화번호 캡처하기

하이픈(`-`)으로 구분된 미국 전화번호(예: `123-456-7890`)를 일치시키려면 다음을 사용할 수 있습니다:

```
/\d\{3\}-\d\{3\}-\d\{4\}
```

미국 전화번호는 세 자리 숫자 세트, 그 다음 또 다른 세 자리 숫자, 그리고 마지막으로 네 자리 숫자로 구성됩니다. 분석해 봅시다:
- `\d\{3\}`는 정확히 세 번 반복되는 숫자와 일치합니다.
- `-`는 리터럴 하이픈입니다.

`\v`로 이스케이프를 입력하지 않아도 됩니다:

```
/\v\d{3}-\d{3}-\d{4}
```

이 패턴은 IP 주소 및 우편번호와 같은 반복되는 숫자를 캡처하는 데에도 유용합니다.

이것으로 이 장의 검색 부분을 다루었습니다. 이제 치환으로 넘어가 봅시다.

## 기본 치환

Vim의 치환 명령어는 모든 패턴을 빠르게 찾아 바꾸는 데 유용한 명령어입니다. 치환 구문은 다음과 같습니다:

```
:s/{old-pattern}/{new-pattern}/
```

기본적인 사용법부터 시작해 봅시다. 다음과 같은 텍스트가 있다면:

```
vim is good
```

Vim은 훌륭하므로 "good"을 "awesome"으로 치환해 봅시다. `:s/good/awesome/`을 실행하세요. 다음과 같이 표시됩니다:

```
vim is awesome
```

## 마지막 치환 반복하기

일반 명령어 `&` 또는 `:s`를 실행하여 마지막 치환 명령어를 반복할 수 있습니다. 방금 `:s/good/awesome/`을 실행했다면, `&`나 `:s`를 실행하면 반복됩니다.

또한, 이 장 앞부분에서 `//`를 사용하여 이전 검색 패턴을 반복할 수 있다고 언급했습니다. 이 트릭은 치환 명령어와 함께 작동합니다. 최근에 `/good`이 수행되었고 첫 번째 치환 패턴 인수를 비워두면, 예를 들어 `:s//awesome/`과 같이, `:s/good/awesome/`을 실행하는 것과 동일하게 작동합니다.

## 치환 범위

많은 Ex 명령어와 마찬가지로, 치환 명령어에 범위 인수를 전달할 수 있습니다. 구문은 다음과 같습니다:

```
:[range]s/old/new/
```

다음과 같은 표현식이 있다면:

```
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

3번 줄부터 5번 줄까지의 "let"을 "const"로 치환하려면 다음을 수행할 수 있습니다:

```
:3,5s/let/const/
```

전달할 수 있는 몇 가지 범위 변형은 다음과 같습니다:
- `:,3s/let/const/` - 쉼표 앞에 아무것도 주어지지 않으면 현재 줄을 나타냅니다. 현재 줄부터 3번 줄까지 치환합니다.
- `:1,s/let/const/` - 쉼표 뒤에 아무것도 주어지지 않으면 현재 줄을 나타냅니다. 1번 줄부터 현재 줄까지 치환합니다.
- `:3s/let/const/` - 범위로 하나의 값만 주어지면(쉼표 없음), 해당 줄에서만 치환을 수행합니다.

Vim에서 `%`는 보통 전체 파일을 의미합니다. `:%s/let/const/`를 실행하면 모든 줄에서 치환을 수행합니다. 이 범위 구문을 명심하세요. 앞으로 배울 많은 커맨드-라인 명령어가 이 형식을 따를 것입니다.

## 패턴 매칭

다음 몇 섹션에서는 기본 정규 표현식을 다룹니다. 강력한 패턴 지식은 치환 명령어를 마스터하는 데 필수적입니다.

다음과 같은 표현식이 있다면:

```
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

숫자 주위에 한 쌍의 큰따옴표를 추가하려면:

```
:%s/\d/"\0"/
```

결과:

```
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

명령어를 분석해 봅시다:
- `:%s`는 치환을 수행하기 위해 전체 파일을 대상으로 합니다.
- `\d`는 Vim의 미리 정의된 숫자 범위입니다(`[0-9]` 사용과 유사).
- `"\0"` 여기서 큰따옴표는 리터럴 큰따옴표입니다. `\0`은 "일치하는 전체 패턴"을 나타내는 특수 문자입니다. 여기서 일치하는 패턴은 단일 숫자 `\d`입니다.

또는, `&`도 `\0`처럼 전체 일치 패턴을 나타냅니다. `:s/\d/"&"/`도 작동했을 것입니다.

다른 예를 고려해 봅시다. 이러한 표현식이 주어지고 모든 "let"을 변수 이름과 바꿔야 한다면.

```
one let = "1";
two let = "2";
three let = "3";
four let = "4";
five let = "5";
```

그렇게 하려면 다음을 실행하세요:

```
:%s/\(\w\+\) \(\w\+\)/\2 \1/
```

위 명령어는 백슬래시가 너무 많아 읽기 어렵습니다. 이 경우 `\v` 연산자를 사용하는 것이 더 편리합니다:

```
:%s/\v(\w+) (\w+)/\2 \1/
```

결과:

```
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

훌륭합니다! 그 명령어를 분석해 봅시다:
- `:%s`는 파일의 모든 줄을 대상으로 치환을 수행합니다.
- `(\w+) (\w+)`는 그룹 일치입니다. `\w`는 Vim의 미리 정의된 단어 문자 범위 중 하나입니다(`[0-9A-Za-z_]`). 그것을 둘러싸는 `( )`는 단어 문자 일치를 그룹으로 캡처합니다. 두 그룹 사이에 공백이 있음을 주목하세요. `(\w+) (\w+)`는 두 그룹을 캡처합니다. 첫 번째 그룹은 "one"을, 두 번째 그룹은 "two"를 캡처합니다.
- `\2 \1`은 캡처된 그룹을 역순으로 반환합니다. `\2`는 캡처된 문자열 "let"을, `\1`은 문자열 "one"을 포함합니다. `\2 \1`은 문자열 "let one"을 반환합니다.

`\0`이 전체 일치 패턴을 나타낸다는 것을 상기하세요. `( )`로 일치하는 문자열을 더 작은 그룹으로 나눌 수 있습니다. 각 그룹은 `\1`, `\2`, `\3` 등으로 표시됩니다.

이 그룹 일치 개념을 확실히 하기 위해 한 가지 예를 더 해봅시다. 다음과 같은 숫자가 있다면:

```
123
456
789
```

순서를 바꾸려면 다음을 실행하세요:

```
:%s/\v(\d)(\d)(\d)/\3\2\1/
```

결과는 다음과 같습니다:

```
321
654
987
```

각 `(\d)`는 각 숫자와 일치하고 그룹을 만듭니다. 첫 번째 줄에서 첫 번째 `(\d)`는 값 1을, 두 번째 `(\d)`는 값 2를, 세 번째 `(\d)`는 값 3을 가집니다. 그것들은 `\1`, `\2`, `\3` 변수에 저장됩니다. 치환의 두 번째 부분에서, 새로운 패턴 `\3\2\1`은 첫 번째 줄에서 "321" 값을 결과로 냅니다.

대신 이것을 실행했다면:

```
:%s/\v(\d\d)(\d)/\2\1/
```
다른 결과를 얻었을 것입니다:

```
312
645
978
```

이것은 이제 두 개의 그룹만 있기 때문입니다. `(\d\d)`에 의해 캡처된 첫 번째 그룹은 `\1` 내에 저장되고 값 12를 가집니다. `(\d)`에 의해 캡처된 두 번째 그룹은 `\2` 내에 저장되고 값 3을 가집니다. 그러면 `\2\1`은 312를 반환합니다.

## 치환 플래그

다음과 같은 문장이 있다면:

```
chocolate pancake, strawberry pancake, blueberry pancake
```

모든 팬케이크를 도넛으로 치환하려면, 그냥 다음을 실행할 수 없습니다:

```
:s/pancake/donut
```

위 명령어는 첫 번째 일치 항목만 치환하여 다음을 제공합니다:

```
chocolate donut, strawberry pancake, blueberry pancake
```

이것을 해결하는 방법에는 두 가지가 있습니다. 치환 명령어를 두 번 더 실행하거나, 전역(`g`) 플래그를 전달하여 한 줄의 모든 일치 항목을 치환할 수 있습니다.

전역 플래그에 대해 이야기해 봅시다. 다음을 실행하세요:

```
:s/pancake/donut/g
```

Vim은 한 번의 빠른 명령어로 모든 팬케이크를 도넛으로 치환합니다. 전역 명령어는 치환 명령어가 허용하는 여러 플래그 중 하나입니다. 치환 명령어 끝에 플래그를 전달합니다. 다음은 유용한 플래그 목록입니다:

```
&    이전 치환 명령어의 플래그 재사용.
g    줄의 모든 일치 항목 바꾸기.
c    치환 확인 요청.
e    치환 실패 시 오류 메시지 표시 방지.
i    대소문자를 구분하지 않는 치환 수행.
I    대소문자를 구분하는 치환 수행.
```

위에 나열하지 않은 더 많은 플래그가 있습니다. 모든 플래그에 대해 읽으려면 `:h s_flags`를 확인하세요.

참고로, 반복-치환 명령어(`&` 및 `:s`)는 플래그를 유지하지 않습니다. `&`를 실행하면 `g` 없이 `:s/pancake/donut/`만 반복됩니다. 모든 플래그와 함께 마지막 치환 명령어를 빠르게 반복하려면 `:&&`를 실행하세요.

## 구분 기호 변경하기

긴 경로가 있는 URL을 바꿔야 하는 경우:

```
https://mysite.com/a/b/c/d/e
```

그것을 "hello"라는 단어로 치환하려면 다음을 실행하세요:

```
:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/
```

하지만, 어떤 슬래시(`/`)가 치환 패턴의 일부이고 어떤 것이 구분 기호인지 구별하기 어렵습니다. 구분 기호를 알파벳, 숫자 또는 `"`, `|`, `\`를 제외한 모든 단일 바이트 문자로 변경할 수 있습니다. `+`로 바꿔 봅시다. 그러면 위 치환 명령어는 다음과 같이 다시 쓸 수 있습니다:

```
:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+
```

이제 구분 기호가 어디에 있는지 더 쉽게 볼 수 있습니다.

## 특수 교체

치환하는 텍스트의 대소문자를 수정할 수도 있습니다. 다음과 같은 표현식이 주어지고 "one", "two", "three" 등 변수를 대문자로 만들어야 한다면.

```
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

다음을 실행하세요:

```
:%s/\v(\w+) (\w+)/\1 \U\2/
```

다음을 얻을 것입니다:

```
let ONE = "1";
let TWO = "2";
let THREE = "3";
let FOUR = "4";
let FIVE = "5";
```

분석:
- `(\w+) (\w+)`는 "let"과 "one"과 같은 처음 두 개의 일치 그룹을 캡처합니다.
- `\1`은 첫 번째 그룹의 값 "let"을 반환합니다.
- `\U\2`는 두 번째 그룹(`\2`)을 대문자로 만듭니다(`\U`).

이 명령어의 트릭은 `\U\2` 표현식입니다. `\U`는 다음 문자를 대문자로 만들도록 지시합니다.

한 가지 예를 더 해봅시다. Vim 가이드를 작성 중이고 한 줄의 각 단어의 첫 글자를 대문자로 만들어야 한다고 가정해 봅시다.

```
vim is the greatest text editor in the whole galaxy
```

다음을 실행할 수 있습니다:

```
:s/\<./\U&/g
```

결과는 다음과 같습니다:

```
Vim Is The Greatest Text Editor In The Whole Galaxy
```

분석은 다음과 같습니다:
- `:s`는 현재 줄을 치환합니다.
- `\<.`는 두 부분으로 구성됩니다: `\<`는 단어의 시작과 일치하고 `.`는 모든 문자와 일치합니다. `\<` 연산자는 다음 문자가 단어의 첫 문자가 되도록 합니다. `.`가 다음 문자이므로, 모든 단어의 첫 문자와 일치합니다.
- `\U&`는 후속 기호 `&`를 대문자로 만듭니다. `&`(또는 `\0`)가 전체 일치를 나타낸다는 것을 상기하세요. 그것은 모든 단어의 첫 문자와 일치합니다.
- `g`는 전역 플래그입니다. 이것이 없으면 이 명령어는 첫 번째 일치 항목만 치환합니다. 이 줄의 모든 일치 항목을 치환해야 합니다.

`\U`와 같은 치환의 특수 교체 기호에 대해 더 배우려면 `:h sub-replace-special`을 확인하세요.

## 대체 패턴

때로는 여러 패턴을 동시에 일치시켜야 할 수도 있습니다. 다음과 같은 인사가 있다면:

```
hello vim
hola vim
salve vim
bonjour vim
```

"hello" 또는 "hola"라는 단어를 포함하는 줄에서만 "vim"이라는 단어를 "friend"로 치환해야 합니다. 이 장 앞부분에서, 여러 대체 패턴에 `|`를 사용할 수 있다는 것을 상기하세요.

```
:%s/\v(hello|hola) vim/\1 friend/g
```

결과:

```
hello friend
hola friend
salve vim
bonjour vim
```

분석은 다음과 같습니다:
- `%s`는 파일의 각 줄에서 치환 명령어를 실행합니다.
- `(hello|hola)`는 "hello" 또는 "hola" 중 *하나*와 일치하고 그것을 그룹으로 간주합니다.
- `vim`은 리터럴 단어 "vim"입니다.
- `\1`은 첫 번째 그룹이며, "hello" 또는 "hola" 텍스트입니다.
- `friend`는 리터럴 단어 "friend"입니다.

## 패턴의 시작과 끝 치환하기

`\zs`와 `\ze`를 사용하여 일치의 시작과 끝을 정의할 수 있다는 것을 상기하세요. 이 기술은 치환에서도 작동합니다. 다음과 같은 것이 있다면:

```
chocolate pancake
strawberry sweetcake
blueberry hotcake
```

"hotcake"의 "cake"를 "dog"로 치환하여 "hotdog"을 얻으려면:

```
:%s/hot\zscake/dog/g
```

결과:

```
chocolate pancake
strawberry sweetcake
blueberry hotdog
```

## 탐욕적과 비탐욕적

이 트릭으로 한 줄의 n번째 일치 항목을 치환할 수 있습니다:

```
One Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.
```

세 번째 "Mississippi"를 "Arkansas"로 치환하려면 다음을 실행하세요:

```
:s/\v(.{-}\zsMississippi){3}/Arkansas/g
```

분석:
- `:s/`는 치환 명령어입니다.
- `\v`는 특수 키워드를 이스케이프할 필요가 없도록 하는 매직 키워드입니다.
- `.`는 모든 단일 문자와 일치합니다.
- `{-}`는 앞선 원자의 0개 이상의 비탐욕적 일치를 수행합니다.
- `\zsMississippi`는 "Mississippi"를 일치의 시작으로 만듭니다.
- `(...){3}`은 세 번째 일치 항목을 찾습니다.

이 장 앞부분에서 `{3}` 구문을 보았습니다. 이 경우, `{3}`은 정확히 세 번째 일치 항목과 일치합니다. 여기서 새로운 트릭은 `{-}`입니다. 이것은 비탐욕적 일치입니다. 주어진 패턴의 가장 짧은 일치를 찾습니다. 이 경우, `(.{-}Mississippi)`는 어떤 문자가 앞에 오는 "Mississippi"의 최소량을 일치시킵니다. 이것을 `(.*Mississippi)`와 대조해 보세요. `(.*Mississippi)`는 주어진 패턴의 가장 긴 일치를 찾습니다.

`(.{-}Mississippi)`를 사용하면 "One Mississippi", "Two Mississippi" 등 다섯 개의 일치 항목을 얻습니다. `(.*Mississippi)`를 사용하면 마지막 "Mississippi"라는 하나의 일치 항목을 얻습니다. `*`는 탐욕적 매처이고 `{-}`는 비탐욕적 매처입니다. 더 배우려면 `:h /\{-` 및 `:h non-greedy`를 확인하세요.

더 간단한 예를 해봅시다. 다음과 같은 문자열이 있다면:

```
abc1de1
```

다음으로 "abc1de1"(탐욕적)을 일치시킬 수 있습니다:

```
/a.*1
```

다음으로 "abc1"(비탐욕적)을 일치시킬 수 있습니다:

```
/a.\{-}1
```

따라서 가장 긴 일치(탐욕적)를 대문자로 만들어야 한다면 다음을 실행하세요:

```
:s/a.*1/\U&/g
```

다음을 얻으려면:

```
ABC1DEFG1
```

가장 짧은 일치(비탐욕적)를 대문자로 만들어야 한다면 다음을 실행하세요:

```
:s/a.\{-}1/\U&/g
```

다음을 얻으려면:

```
ABC1defg1
```

탐욕적 대 비탐욕적 개념이 처음이라면, 머릿속에 정리하기 어려울 수 있습니다. 이해할 때까지 다른 조합으로 실험해보세요.

## 여러 파일에 걸쳐 치환하기

마지막으로, 여러 파일에 걸쳐 구문을 치환하는 방법을 배워봅시다. 이 섹션에서는 `food.txt`와 `animal.txt`라는 두 개의 파일이 있다고 가정합니다.

`food.txt` 내부:

```
corndog
hotdog
chilidog
```

`animal.txt` 내부:

```
large dog
medium dog
small dog
```

디렉토리 구조가 다음과 같다고 가정합니다:

```
- food.txt
- animal.txt
```

먼저, `:args` 안에 `food.txt`와 `animal.txt`를 모두 캡처합니다. 이전 장에서 `:args`를 사용하여 파일 이름 목록을 만들 수 있다는 것을 상기하세요. Vim 내부에서 이 작업을 수행하는 여러 가지 방법이 있으며, 그중 하나는 Vim 내부에서 다음을 실행하는 것입니다:

```
:args *.txt                  현재 위치의 모든 txt 파일 캡처
```

테스트하려면, `:args`를 실행하면 다음을 볼 수 있습니다:

```
[food.txt] animal.txt
```

이제 모든 관련 파일이 인수 목록 안에 저장되었으므로, `:argdo` 명령어로 다중 파일 치환을 수행할 수 있습니다. 다음을 실행하세요:

```
:argdo %s/dog/chicken/
```

이것은 `:args` 목록 안의 모든 파일에 대해 치환을 수행합니다. 마지막으로, 변경된 파일을 다음으로 저장합니다:

```
:argdo update
```

`:args`와 `:argdo`는 여러 파일에 걸쳐 커맨드-라인 명령어를 적용하는 데 유용한 도구입니다. 다른 명령어로 시도해보세요!

## 매크로로 여러 파일에 걸쳐 치환하기

또는, 매크로로 여러 파일에 걸쳐 치환 명령어를 실행할 수도 있습니다. 다음을 실행하세요:

```
:args *.txt
qq
:%s/dog/chicken/g
:wnext
q
99@q
```

분석:
- `:args *.txt`는 모든 텍스트 파일을 `:args` 목록에 추가합니다.
- `qq`는 "q" 레지스터에서 매크로를 시작합니다.
- `:%s/dog/chicken/g`는 현재 파일의 모든 줄에서 "dog"을 "chicken"으로 치환합니다.
- `:wnext`는 파일을 저장한 다음 `args` 목록의 다음 파일로 이동합니다.
- `q`는 매크로 기록을 중지합니다.
- `99@q`는 매크로를 99번 실행합니다. Vim은 첫 번째 오류를 만나면 매크로 실행을 중지하므로, Vim은 실제로 매크로를 99번 실행하지 않습니다.

## 현명하게 검색 및 치환 배우기

검색을 잘하는 능력은 편집에 필수적인 기술입니다. 검색을 마스터하면 정규 표현식의 유연성을 활용하여 파일의 모든 패턴을 검색할 수 있습니다. 이것들을 배우는 데 시간을 투자하세요. 정규 표현식에 더 능숙해지려면 정규 표현식을 적극적으로 사용해야 합니다. 저는 한때 실제로 해보지 않고 정규 표현식에 관한 책을 읽었고, 나중에 읽은 거의 모든 것을 잊어버렸습니다. 적극적인 코딩은 모든 기술을 마스터하는 가장 좋은 방법입니다.

패턴 매칭 기술을 향상시키는 좋은 방법은 패턴("hello 123"과 같은)을 검색해야 할 때마다, 리터럴 검색어(`/hello 123`)를 쿼리하는 대신, 그것에 대한 패턴(예: `/\v(\l+) (\d+)`)을 생각해내는 것입니다. 이러한 정규 표현식 개념 중 많은 것들이 Vim을 사용할 때뿐만 아니라 일반적인 프로그래밍에서도 적용됩니다.

이제 Vim에서 고급 검색 및 치환에 대해 배웠으니, 가장 다재다능한 명령어 중 하나인 전역 명령어에 대해 배워봅시다.