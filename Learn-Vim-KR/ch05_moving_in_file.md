# Ch05. 파일 안에서 이동하기

처음에는 키보드로 이동하는 것이 느리고 어색하게 느껴지지만 포기하지 마세요! 익숙해지면 마우스를 사용하는 것보다 파일 안 어디든 더 빨리 갈 수 있습니다.

이 장에서는 필수적인 모션과 그것들을 효율적으로 사용하는 방법을 배울 것입니다. 이것이 Vim이 가진 **전체** 모션이 아니라는 점을 명심하세요. 여기서의 목표는 빠르게 생산성을 높일 수 있는 유용한 모션을 소개하는 것입니다. 더 배우고 싶다면 `:h motion.txt`를 확인하세요.

## 문자 단위 이동

가장 기본적인 이동 단위는 한 문자씩 왼쪽, 아래, 위, 오른쪽으로 움직이는 것입니다.

```
h   왼쪽
j   아래
k   위
l   오른쪽
gj  줄바꿈된 줄에서 아래로
gk  줄바꿈된 줄에서 위로
```

방향키로도 이동할 수 있습니다. 이제 막 시작했다면 가장 편한 방법을 자유롭게 사용하세요.

저는 오른손이 홈 로우에 머무를 수 있기 때문에 `hjkl`을 선호합니다. 이렇게 하면 주변 키에 더 짧게 닿을 수 있습니다. `hjkl`에 익숙해지기 위해, 저는 처음에 `~/.vimrc`에 다음을 추가하여 화살표 버튼을 비활성화했습니다:

```
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>
```

이 나쁜 습관을 고치는 데 도움이 되는 플러그인도 있습니다. 그중 하나는 [vim-hardtime](https://github.com/takac/vim-hardtime)입니다. 놀랍게도, 저는 `hjkl`에 익숙해지는 데 일주일도 채 걸리지 않았습니다.

Vim이 왜 `hjkl`을 이동에 사용하는지 궁금하다면, 이는 빌 조이가 Vi를 작성한 Lear-Siegler ADM-3A 터미널에 화살표 키가 없었고 `hjkl`을 왼쪽/아래/위/오른쪽으로 사용했기 때문입니다.*

## 상대 번호 매기기

`number`와 `relativenumber`를 설정하는 것이 도움이 된다고 생각합니다. `.vimrc`에 다음을 추가하여 할 수 있습니다:

```
set relativenumber number
```

이것은 현재 줄 번호와 상대적인 줄 번호를 표시합니다.

왼쪽 열에 번호가 있는 것이 왜 유용한지는 쉽게 알 수 있지만, 왼쪽 열에 상대 번호가 있는 것이 어떻게 유용할지 묻는 분도 있을 것입니다. 상대 번호가 있으면 커서가 대상 텍스트에서 몇 줄 떨어져 있는지 빠르게 확인할 수 있습니다. 이것으로 대상 텍스트가 제 아래 12줄에 있다는 것을 쉽게 파악하여 `d12j`로 삭제할 수 있습니다. 그렇지 않으면, 제가 69번 줄에 있고 대상이 81번 줄에 있다면, 암산을 해야 합니다 (81 - 69 = 12). 편집 중에 수학을 하는 것은 너무 많은 정신적 자원을 소모합니다. 어디로 가야 할지 덜 생각할수록 좋습니다.

이것은 100% 개인적인 취향입니다. `relativenumber` / `norelativenumber`, `number` / `nonumber`를 실험해보고 가장 유용하다고 생각하는 것을 사용하세요!

## 이동 횟수 세기

"count" 인수에 대해 이야기해 봅시다. Vim 모션은 앞에 숫자 인수를 받습니다. 위에서 `12j`로 12줄 아래로 갈 수 있다고 언급했습니다. `12j`의 12가 횟수입니다.

모션과 함께 횟수를 사용하는 구문은 다음과 같습니다:

```
[count] + motion
```

이것을 모든 모션에 적용할 수 있습니다. 오른쪽으로 9문자 이동하고 싶다면, `l`을 9번 누르는 대신 `9l`을 할 수 있습니다.

## 단어 단위 이동

더 큰 이동 단위인 *단어*로 이동해 봅시다. 다음 단어의 시작(`w`), 다음 단어의 끝(`e`), 이전 단어의 시작(`b`), 이전 단어의 끝(`ge`)으로 이동할 수 있습니다.

또한, 단어와 구별되는 *WORD*가 있습니다. 다음 WORD의 시작(`W`), 다음 WORD의 끝(`E`), 이전 WORD의 시작(`B`), 이전 WORD의 끝(`gE`)으로 이동할 수 있습니다. 기억하기 쉽도록, WORD는 단어와 같은 글자를 사용하되 대문자로만 사용합니다.

```
w     다음 단어의 시작으로 앞으로 이동
W     다음 WORD의 시작으로 앞으로 이동
e     다음 단어의 끝으로 한 단어 앞으로 이동
E     다음 WORD의 끝으로 한 단어 앞으로 이동
b     이전 단어의 시작으로 뒤로 이동
B     이전 WORD의 시작으로 뒤로 이동
ge    이전 단어의 끝으로 뒤로 이동
gE    이전 WORD의 끝으로 뒤로 이동
```

그렇다면 단어와 WORD의 유사점과 차이점은 무엇일까요? 단어와 WORD는 모두 공백 문자로 구분됩니다. 단어는 *오직* `a-zA-Z0-9_`만 포함하는 문자 시퀀스입니다. WORD는 공백(공백은 스페이스, 탭, EOL을 의미)을 제외한 모든 문자 시퀀스입니다. 더 배우려면 `:h word`와 `:h WORD`를 확인하세요.

예를 들어, 다음과 같은 코드가 있다고 가정해 봅시다:

```
const hello = "world";
```

줄의 시작에 커서가 있을 때, `l`로 줄의 끝까지 가려면 21번의 키 입력이 필요합니다. `w`를 사용하면 6번이 걸립니다. `W`를 사용하면 단 4번만 걸립니다. 단어와 WORD는 모두 짧은 거리를 이동하는 데 좋은 옵션입니다.

하지만, 현재 줄 이동을 사용하면 "c"에서 ";"까지 한 번의 키 입력으로 갈 수 있습니다.

## 현재 줄 이동

편집할 때, 종종 줄에서 수평으로 이동해야 합니다. 현재 줄의 첫 문자로 점프하려면 `0`을 사용합니다. 현재 줄의 마지막 문자로 가려면 `$`를 사용합니다. 또한, `^`를 사용하여 현재 줄의 공백이 아닌 첫 문자로, `g_`를 사용하여 현재 줄의 공백이 아닌 마지막 문자로 갈 수 있습니다. 현재 줄의 `n`번째 열로 가고 싶다면 `n|`를 사용할 수 있습니다.

```
0     현재 줄의 첫 문자로 이동
^     현재 줄의 공백이 아닌 첫 문자로 이동
g_    현재 줄의 공백이 아닌 마지막 문자로 이동
$     현재 줄의 마지막 문자로 이동
n|    현재 줄의 n번째 열로 이동
```

`f`와 `t`로 현재 줄 검색을 할 수 있습니다. `f`와 `t`의 차이점은 `f`는 일치하는 첫 글자로 이동하고 `t`는 일치하는 첫 글자 바로 앞까지 이동한다는 것입니다. 따라서 "h"를 검색하여 "h"에 착지하고 싶다면 `fh`를 사용하세요. 첫 "h"를 검색하여 일치하는 곳 바로 전에 착지하고 싶다면 `th`를 사용하세요. 마지막 현재 줄 검색의 다음 발생으로 가고 싶다면 `;`를 사용하세요. 마지막 현재 줄 일치의 이전 발생으로 가려면 `,`를 사용하세요.

`F`와 `T`는 `f`와 `t`의 뒤로 가는 상대입니다. "h"를 뒤로 검색하려면 `Fh`를 실행하세요. 같은 방향으로 "h"를 계속 검색하려면 `;`를 사용하세요. `Fh` 뒤의 `;`는 뒤로 검색하고 `Fh` 뒤의 `,`는 앞으로 검색한다는 점에 유의하세요.

```
f    같은 줄에서 앞으로 일치하는 항목 검색
F    같은 줄에서 뒤로 일치하는 항목 검색
t    같은 줄에서 앞으로 일치하는 항목 검색, 일치하는 항목 앞에서 멈춤
T    같은 줄에서 뒤로 일치하는 항목 검색, 일치하는 항목 앞에서 멈춤
;    같은 방향으로 마지막 검색 반복
,    반대 방향으로 마지막 검색 반복
```

이전 예제로 돌아가서:

```
const hello = "world";
```

줄의 시작에 커서가 있을 때, 한 번의 키 입력으로 현재 줄의 마지막 문자(";")로 갈 수 있습니다: `$`. "world"의 "w"로 가고 싶다면, `fw`를 사용할 수 있습니다. 줄 안 어디든 가기 위한 좋은 팁은 대상 근처에서 "j", "x", "z"와 같이 덜 흔한 글자를 찾는 것입니다.

## 문장 및 문단 이동

다음 두 이동 단위는 문장과 문단입니다.

먼저 문장이 무엇인지 이야기해 봅시다. 문장은 `. ! ?` 중 하나로 끝나고 그 뒤에 EOL, 공백 또는 탭이 옵니다. `)`로 다음 문장으로, `(`로 이전 문장으로 점프할 수 있습니다.

```
(    이전 문장으로 점프
)    다음 문장으로 점프
```

몇 가지 예를 살펴봅시다. 어떤 구문이 문장이고 어떤 것이 아닌지 생각해보세요. Vim에서 `(`와 `)`로 이동해보세요!

```
I am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :

There is an empty line above me.
```

참고로, `.` 뒤에 한 줄이 오는 구문에 대해 Vim이 문장으로 계산하지 않는 문제가 있다면 `'compatible'` 모드일 수 있습니다. vimrc에 `set nocompatible`을 추가하세요. Vi에서 문장은 `.` 뒤에 **두 개**의 공백이 오는 것입니다. 항상 `nocompatible`을 설정해야 합니다.

문단이 무엇인지 이야기해 봅시다. 문단은 각 빈 줄 뒤에 시작되며, `paragraphs` 옵션의 문자 쌍으로 지정된 문단 매크로 세트에서도 시작됩니다.

```
{    이전 문단으로 점프
}    다음 문단으로 점프
```

문단 매크로가 무엇인지 확실하지 않다면 걱정하지 마세요. 중요한 것은 문단이 빈 줄 뒤에 시작하고 끝난다는 것입니다. 이것은 대부분의 경우에 해당됩니다.

이 예를 살펴봅시다. `}`와 `{`로 이동해보세요 (또한, 문장 이동 `( )`으로도 이동해보세요!)

```
Hello. How are you? I am great, thanks!
Vim is awesome.
It may not easy to learn it at first...- but we are in this together. Good luck!

Hello again.

Try to move around with ), (, }, and {. Feel how they work.
You got this.
```

더 배우려면 `:h sentence`와 `:h paragraph`를 확인하세요.

## 짝 이동

프로그래머는 코드를 작성하고 편집합니다. 코드는 일반적으로 괄호, 중괄호, 대괄호를 사용합니다. 그 안에서 쉽게 길을 잃을 수 있습니다. 하나 안에 있다면, `%`로 다른 쌍(존재하는 경우)으로 점프할 수 있습니다. 이것을 사용하여 일치하는 괄호, 중괄호, 대괄호가 있는지 확인할 수도 있습니다.

```
%    다른 짝으로 이동, 보통 (), [], {}에 작동
```

괄호를 광범위하게 사용하는 Scheme 코드 예를 살펴봅시다. 다른 괄호 안에서 `%`로 이동해보세요.

```
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else
          (+ (fib (- n 1)) (fib (- n 2)))
        )))
```

저는 개인적으로 [vim-rainbow](https://github.com/frazrepo/vim-rainbow)와 같은 시각적 표시기 플러그인으로 `%`를 보완하는 것을 좋아합니다. 더 많은 정보를 원하시면 `:h %`를 확인하세요.

## 줄 번호 이동

`nG`로 `n`번 줄로 점프할 수 있습니다. 예를 들어, 7번 줄로 점프하고 싶다면 `7G`를 사용하세요. 첫 번째 줄로 점프하려면 `1G` 또는 `gg`를 사용하세요. 마지막 줄로 점프하려면 `G`를 사용하세요.

종종 대상이 정확히 몇 번 줄에 있는지 모르지만, 전체 파일의 약 70% 지점에 있다는 것을 알고 있습니다. 이 경우 `70%`를 할 수 있습니다. 파일의 중간으로 점프하려면 `50%`를 할 수 있습니다.

```
gg    첫 번째 줄로 이동
G     마지막 줄로 이동
nG    n번 줄로 이동
n%    파일의 n% 지점으로 이동
```

참고로, 파일의 총 줄 수를 보고 싶다면 `Ctrl-g`를 사용할 수 있습니다.

## 창 이동

창의 맨 위, 중간 또는 맨 아래로 빠르게 이동하려면 `H`, `M`, `L`을 사용할 수 있습니다.

`H`와 `L`에 횟수를 전달할 수도 있습니다. `10H`를 사용하면 창 상단에서 10줄 아래로 이동합니다. `3L`을 사용하면 창 마지막 줄에서 3줄 위로 이동합니다.

```
H     화면 상단으로 이동
M     화면 중간으로 이동
L     화면 하단으로 이동
nH    상단에서 n번째 줄로 이동
nL    하단에서 n번째 줄로 이동
```

## 스크롤하기

스크롤하려면 전체 화면(`Ctrl-F`/`Ctrl-B`), 반 화면(`Ctrl-D`/`Ctrl-U`), 한 줄(`Ctrl-E`/`Ctrl-Y`)의 3가지 속도 증가가 있습니다.

```
Ctrl-E    한 줄 아래로 스크롤
Ctrl-D    반 화면 아래로 스크롤
Ctrl-F    전체 화면 아래로 스크롤
Ctrl-Y    한 줄 위로 스크롤
Ctrl-U    반 화면 위로 스크롤
Ctrl-B    전체 화면 위로 스크롤
```

현재 줄을 기준으로 스크롤할 수도 있습니다 (화면 시야 확대):

```
zt    현재 줄을 화면 상단 가까이로 가져오기
zz    현재 줄을 화면 중간으로 가져오기
zb    현재 줄을 화면 하단 가까이로 가져오기
```

## 검색 이동

종종 파일 안에 구문이 있다는 것을 알고 있습니다. 검색 이동을 사용하여 대상에 매우 빠르게 도달할 수 있습니다. 구문을 검색하려면 `/`를 사용하여 앞으로 검색하고 `?`를 사용하여 뒤로 검색할 수 있습니다. 마지막 검색을 반복하려면 `n`을 사용할 수 있습니다. 반대 방향으로 마지막 검색을 반복하려면 `N`을 사용할 수 있습니다.

```
/    앞으로 일치하는 항목 검색
?    뒤로 일치하는 항목 검색
n    이전 검색과 같은 방향으로 마지막 검색 반복
N    이전 검색과 반대 방향으로 마지막 검색 반복
```

다음과 같은 텍스트가 있다고 가정해 봅시다:

```
let one = 1;
let two = 2;
one = "01";
one = "one";
let onetwo = 12;
```

"let"을 검색하는 경우 `/let`을 실행하세요. "let"을 다시 빠르게 검색하려면 `n`을 누르면 됩니다. 반대 방향으로 "let"을 다시 검색하려면 `N`을 실행하세요. `?let`을 실행하면 "let"을 뒤로 검색합니다. `n`을 사용하면 이제 "let"을 뒤로 검색합니다 (`N`은 이제 "let"을 앞으로 검색합니다).

`set hlsearch`로 검색 강조를 활성화할 수 있습니다. 이제 `/let`을 검색하면 파일의 모든 일치하는 구문이 강조 표시됩니다. 또한, `set incsearch`로 점진적 검색을 설정할 수 있습니다. 이것은 입력하는 동안 패턴을 강조 표시합니다. 기본적으로 일치하는 구문은 다른 구문을 검색할 때까지 강조 표시된 상태로 유지됩니다. 이것은 금방 짜증나는 일이 될 수 있습니다. 강조 표시를 비활성화하려면 `:nohlsearch` 또는 간단히 `:noh`를 실행할 수 있습니다. 이 비강조 표시 기능을 자주 사용하기 때문에 vimrc에 맵을 만들었습니다:

```
nnoremap <esc><esc> :noh<return><esc>
```

`*`를 사용하여 커서 아래의 텍스트를 앞으로 검색하고 `#`을 사용하여 뒤로 검색할 수 있습니다. 커서가 "one" 문자열 위에 있다면, `*`를 누르는 것은 `/\<one\>`을 한 것과 같습니다.

`/\<one\>`의 `\<`와 `\>`는 모두 전체 단어 검색을 의미합니다. 더 큰 단어의 일부인 경우 "one"과 일치하지 않습니다. "one" 단어와는 일치하지만 "onetwo"와는 일치하지 않습니다. 커서가 "one" 위에 있고 "one"과 "onetwo"와 같은 전체 또는 부분 단어와 일치하도록 앞으로 검색하려면 `*` 대신 `g*`를 사용해야 합니다.

```
*     커서 아래의 전체 단어를 앞으로 검색
#     커서 아래의 전체 단어를 뒤로 검색
g*    커서 아래의 단어를 앞으로 검색
g#    커서 아래의 단어를 뒤로 검색

```
## 위치 표시하기

마크를 사용하여 현재 위치를 저장하고 나중에 이 위치로 돌아올 수 있습니다. 텍스트 편집을 위한 북마크와 같습니다. `mx`로 마크를 설정할 수 있으며, 여기서 `x`는 알파벳 문자 `a-zA-Z`가 될 수 있습니다. 마크로 돌아가는 방법에는 두 가지가 있습니다: `` `x``로 정확하게(줄과 열) 돌아가거나 `'x`로 줄 단위로 돌아갑니다.

```
ma    "a" 마크로 위치 표시
`a    "a" 마크의 줄과 열로 점프
'a    "a" 마크의 줄로 점프
```

소문자(a-z)와 대문자(A-Z)로 표시하는 것에는 차이가 있습니다. 소문자 알파벳은 로컬 마크이고 대문자 알파벳은 글로벌 마크(때로는 파일 마크라고도 함)입니다.

로컬 마크에 대해 이야기해 봅시다. 각 버퍼는 고유한 로컬 마크 세트를 가질 수 있습니다. 두 개의 파일이 열려 있는 경우, 첫 번째 파일에 마크 "a"(`ma`)를 설정하고 두 번째 파일에 다른 마크 "a"(`ma`)를 설정할 수 있습니다.

각 버퍼에 마크 세트를 가질 수 있는 로컬 마크와 달리, 글로벌 마크는 한 세트만 가질 수 있습니다. `myFile.txt` 안에 `mA`를 설정하면 다음에 다른 파일에서 `mA`를 실행할 때 첫 번째 "A" 마크를 덮어씁니다. 글로벌 마크의 한 가지 장점은 완전히 다른 프로젝트 안에 있더라도 모든 글로벌 마크로 점프할 수 있다는 것입니다. 글로벌 마크는 파일을 넘나들 수 있습니다.

모든 마크를 보려면 `:marks`를 사용하세요. 마크 목록에서 `a-zA-Z` 이외의 더 많은 마크가 있는 것을 알 수 있습니다. 그중 일부는 다음과 같습니다:

```
''    점프 전 현재 버퍼의 마지막 줄로 돌아가기
``    점프 전 현재 버퍼의 마지막 위치로 돌아가기
`[    이전에 변경/복사된 텍스트의 시작으로 점프
`]    이전에 변경/복사된 텍스트의 끝으로 점프
`<    마지막 비주얼 선택의 시작으로 점프
`>    마지막 비주얼 선택의 끝으로 점프
`0    vim 종료 시 마지막으로 편집한 파일로 돌아가기
```

위에 나열된 것보다 더 많은 마크가 있습니다. 거의 사용되지 않는다고 생각하여 여기서는 다루지 않겠지만, 궁금하다면 `:h marks`를 확인하세요.

## 점프

Vim에서는 일부 모션을 사용하여 다른 파일이나 파일의 다른 부분으로 "점프"할 수 있습니다. 하지만 모든 모션이 점프로 간주되는 것은 아닙니다. `j`로 아래로 가는 것은 점프로 간주되지 않습니다. `10G`로 10번 줄로 가는 것은 점프로 간주됩니다.

다음은 Vim이 "점프" 명령어로 간주하는 명령어입니다:

```
'       표시된 줄로 이동
`       표시된 위치로 이동
G       줄로 이동
/       앞으로 검색
?       뒤로 검색
n       마지막 검색 반복, 같은 방향
N       마지막 검색 반복, 반대 방향
%       짝 찾기
(       이전 문장으로 이동
)       다음 문장으로 이동
{       이전 문단으로 이동
}       다음 문단으로 이동
L       표시된 창의 마지막 줄로 이동
M       표시된 창의 중간 줄로 이동
H       표시된 창의 첫 줄로 이동
[[      이전 섹션으로 이동
]]      다음 섹션으로 이동
:s      치환
:tag    태그 정의로 점프
```

이 목록을 외우는 것은 권장하지 않습니다. 좋은 경험 법칙은, 단어와 현재 줄 이동보다 더 멀리 움직이는 모든 모션은 아마도 점프라는 것입니다. Vim은 여러분이 이동할 때 어디에 있었는지 추적하며, 이 목록은 `:jumps` 안에서 볼 수 있습니다.

더 많은 정보는 `:h jump-motions`를 확인하세요.

점프는 왜 유용할까요? 점프 목록을 `Ctrl-O`로 위로, `Ctrl-I`로 아래로 이동할 수 있기 때문입니다. `hjkl`은 "점프" 명령어가 아니지만, 이동 전에 `m'`로 현재 위치를 점프 목록에 수동으로 추가할 수 있습니다. 예를 들어, `m'5j`는 현재 위치를 점프 목록에 추가하고 5줄 아래로 이동하며, `Ctrl-O`로 돌아올 수 있습니다. 다른 파일 간에 점프할 수 있으며, 이에 대해서는 다음 부분에서 더 자세히 논의하겠습니다.

## 현명하게 이동 배우기

Vim을 처음 접하는 경우, 배울 것이 많습니다. 누구도 모든 것을 즉시 기억할 것으로 기대하지 않습니다. 생각 없이 실행할 수 있기까지는 시간이 걸립니다.

시작하는 가장 좋은 방법은 몇 가지 필수적인 모션을 외우는 것이라고 생각합니다. `h, j, k, l, w, b, G, /, ?, n` 이 10가지 모션으로 시작하는 것을 추천합니다. 생각 없이 사용할 수 있을 때까지 충분히 반복하세요.

이동 기술을 향상시키기 위한 제 제안은 다음과 같습니다:
1. 반복적인 행동을 주시하세요. `l`을 반복적으로 하고 있다면, 더 빨리 앞으로 갈 수 있는 모션을 찾아보세요. `w`를 사용할 수 있다는 것을 알게 될 것입니다. `w`를 반복적으로 하고 있다면, 현재 줄을 빠르게 가로지를 수 있는 모션이 있는지 찾아보세요. `f`를 사용할 수 있다는 것을 알게 될 것입니다. 필요를 간결하게 설명할 수 있다면, Vim에 그것을 할 방법이 있을 가능성이 높습니다.
2. 새로운 움직임을 배울 때마다, 생각 없이 할 수 있을 때까지 시간을 보내세요.

마지막으로, 생산성을 높이기 위해 모든 Vim 명령어를 알 필요는 없다는 것을 깨달으세요. 대부분의 Vim 사용자는 그렇지 않습니다. 저도 그렇습니다. 그 순간에 작업을 완수하는 데 도움이 되는 명령어를 배우세요.

시간을 가지세요. 이동 기술은 Vim에서 매우 중요한 기술입니다. 매일 작은 것 하나를 배우고 그것을 잘 배우세요.